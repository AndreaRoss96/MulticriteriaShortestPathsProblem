%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come è à
                                        %   si può usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   però con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{array}
\usepackage{graphicx}
\usepackage{algorithm,algpseudocode}
\usepackage{lipsum}
\usepackage{xparse}
\usepackage{multirow}

\usepackage{imakeidx}

\usepackage{blindtext}

\graphicspath{ {Report/img/} }
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{sil-la-ba-zio-ne pa-ren-te-si}%serve per la sillabazione: tra parentesi 
					   %vanno inserite come nell'esempio le parole 
%					   %che latex non riesce a tagliare nel modo giusto andando a capo.

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
%

\newsavebox{\fminipagebox}
\NewDocumentEnvironment{fminipage}{m O{\fboxsep}}
{\par\kern#2\noindent\begin{lrbox}{\fminipagebox}
		\begin{minipage}{#1}\ignorespaces}
		{\end{minipage}\end{lrbox}%
	\makebox[#1]{%
		\kern\dimexpr-\fboxsep-\fboxrule\relax
		\fbox{\usebox{\fminipagebox}}%
		\kern\dimexpr-\fboxsep-\fboxrule\relax
	}\par\kern#2
}

\begin{document}
	
	\begin{titlepage}
		\begin{center}
			{{\large{\textsc{Alma Mater Studiorum $\cdot$ Universit\`a di
							Bologna\\Campus di Cesena}}}} \rule[0.2cm]{15.8cm}{0.2mm}
			\rule[0.5cm]{15.8cm}{0.6mm}
{\small 			{{\bf DIPARTIMENTO DI INFORMATICA - SCIENZA E INGEGNERIA\\
					CORSO DI LAUREA IN INGEGNERIA E SCIENZE INFORMATICHE
			}}}
		\end{center}
		\vspace{5mm}
		\begin{center}
			%{\LARGE{\bf TITOLO DELL'ELABORATO}}\\
			%\vspace{5mm}
			{\LARGE{\bf Analysis and Implementation of Algorithms for Bicriteria Shortest Paths Problems}}\\
			\vspace{3mm}
		\end{center}
		\vspace{3mm}
		\begin{center}
			\large{Elaborato in\\
				RICERCA OPERATIVA}
		\end{center}
		\vspace{30mm}
		\par
		\noindent
		\begin{minipage}[t]{0.47\textwidth}
			{\large{\bf Relatore:\\
					VIGO DANIELE}}
		\end{minipage}
		\vspace{5mm}
		\begin{minipage}[t]{0.47\textwidth}\raggedleft
			{\large{\bf Presentata da:\\
					ROSSOLINI ANDREA}}
		\end{minipage}\\
		\begin{minipage}[t]{1.5\textwidth}\raggedright
			{\large{\bf Corelatore:\\
					N\'ERON EMMANUEL}}
		\end{minipage}
		\hfill
		\vspace{20mm}
		\begin{center}
			{\large{\bf Anno Accademico: 2018/2019\\III sessione di laurea}}%inserire l'anno accademico a cui si è iscritti
		\end{center}
	\end{titlepage}
	
	\begin{abstract}
		Questa tesi si pone l'obbiettivo di affrontare ed analizzare un problema di \textit{pathfinding} partendo da uno studio su di alcuni algoritmi per la ricerca del percorso più breve su classici grafi, per poi, dopo alcune ottimizzazioni, lavorare con grafi che utilizzano due pesi per ogni arco, considerando l'insieme di soluzioni più soddisfacenti.
		
		Dato che, lo studio di algoritmi per la ricerca dei percorsi più brevi nei grafi è piuttosto celebre in letteratura, è ormai facile elaborare un'implementazione che permetta di risolvere questo problema, verrà effettuata quindi una rapida implementazione ed analisi. Differente è il discorso per agli algoritmi che lavorano in grafi con più pesi, per i quali è più difficile reperire implementazioni ed analisi. Inoltre, essendo un lavoro di ottimizzazione mi concentrerò sull'analisi di grafi con due pesi, seppur alcuni algoritmi siano applicabili anche a grafi con un più vasta moltitudine di valori.
		%
		
	\end{abstract}
	
\begin{titlepage}                       %crea un ambiente libero da vincoli 
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
%
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Dedico questo mio modesto lavoro a tutti coloro\\
Che mi sono stati vicini e mi hanno sostenuto\\
In questa piccola parte di un ancora faticoso cammino\\
In particolare alla mia famiglia che non ha mai smesso di credere in me \ldots                      %\ldots lascia tre puntini
\newpage                                %va in una pagina nuova
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}%non numera l'ultima pagina sinistra
\end{titlepage}


%\chapter*{Introduzione}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
%\rhead[\fancyplain{}{\bfseries
%INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
%\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
%INTRODUZIONE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
%\addcontentsline{toc}{chapter}{Introduzione}
%Questa \`e l'introduzione.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
%\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoffigures                          %crea l'elenco delle figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoftables                           %crea l'elenco delle tabelle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Introduzione}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
L'algoritmo di Dijkstra è largamente utilizzato in ambiti dove i problemi di routing riguardano grafi dove sono presenti valori statici non negativi. Questo celebre algoritmo però prende in considerazione una sola ``dimensione" dei costi;  se, ad esempio, ci fosse la necessità di calcolare il percorso in un grafo da un nodo \textit{sorgete} ad uno  \textit{destinazione} questo troverebbe il percorso addizionando volta per volta il peso relativo all'arco che connette due nodi che vengono "visitati" dall'algoritmo. Ma il problema si ha appunto nel momento in cui si hanno due o più criteri che relazionano due nodi; ad esempio la distanza e il pericolo. In questo caso si potrebbe scegliere tra diversi percorsi (seppur rappresentati all'interno di un grafo), ma non per forza il più corto è anche il più sicuro o vice versa. La ricerca di un percorso breve in termini di differenti criteri (molto più semplicemente in inglese `\textit{Muticriteria Shortest Paths Problem}') ha lo scopo di ottimizzare i costi dal nodo sorgente a quello di destinazione.\\
In generale non c'è una sola soluzione ottimale, bensì un insieme di possibili soluzioni, anche dette soluzioni ``non dominate" (verrà in seguito approfondito il significato di questa espressione). L'obiettivo di questo progetto è dunque quello di implementare l'algoritmo migliore che possa trovare questo insieme di soluzioni non solo minimizzando il primo o il secondo peso, ma la loro relazione.

\vspace{5mm}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{exampleGraph1}
	\caption{Grafo d'esempio.}
	\label{fig:graphExample}
\end{figure}

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		$p1$ & $1\to2\to4\to6$ & (11, 25) \\ \hline
		$p2$ & $1\to2\to5\to6$ & (13, 11)  \\ \hline
		$p3$ & $1\to3\to5\to6$ & (21, 6)  \\ \hline
		$p4$ & $1\to3\to4\to6$ & (13, 18)  \\ \hline
	\end{tabular}
	\caption{Soluzione del grafo di esempio}
	\label{tab:graphExample}
\end{table}

La fig.\ref{fig:graphExample} mostra un esempio di grafo a due criteri. Ogni nodo è numerato $\{1,2,\dots,6\}$ ed i pesi presenti sugli archi sono rappresentati come una coppia di valori $(a,b)$. Se considerassimo il primo peso la distanza e il secondo peso, ad esempio, il pericolo, avremo i percorsi $p1$ e $p3$ come il più corto ed il più sicuro rispettivamente, differentemente $p2$ è una soluzione definita ``non dominata", infatti comprende un percorso più lungo rispetto a $p1$, ma al contempo più sicuro, mentre percorre un cammino più pericoloss, ma più corto rispetto a ``p3". $p4$ infine segue un percorso che non risulta vantaggioso ne per il primo valore ne per il secondo, in quanto non porta nessun vantaggio rispetto a $p2$ (la definizione formale di ``soluzione dominata" sarà formulata nel cap.3).

\section{Formulazione Matematica}                 %crea la sezione
Sia definita $G(N,A)$ un grafo orientato composto da un insieme finito di nodi (o vertici) $N = \{0,1,\dots,n\}$ e $A \subseteq N\times N $ di archi direzionati. Ogni arco può essere rappresentato come una coppia ordinata $(i,j)$, dove $i\in N$, $j \in N$ ed entrambi due nodi differenti ($i\neq j$) in $G(N,A)$.

Sia dunque definito $c^k_{i,j}$ dove $(i,j)\in A$ e $1\leq k \leq 2$ (dato che si tratta di un grafo con due pesi ad ogni arco) che rappresentano i costi relativi ad ogni arco. Considerando quindi due nodi del grafo, chiamati $s$ e $t$, dove $s,t\in N$, i quali rappresentano rispettivamente il nodo da cui iniziano i percorsi che cerchiamo (\textit{source}) ed il nodo terminale (\textit{target}).
Un cammino $p_{s,t}$ può essere rappresentato come una sequenza di nodi e archi, avente la seguente forma: $p_{s,t} = \{s, (s, i_1), i_1, \dots, i_{l}, (i_l,t), t\}$.\\
\'E dunque possibile affermare che ogni $c^k_{i,j}$ rappresenta il costo di uno dei $k$ pesi di ogni arco $(i,j)$, quindi il costo totale dell'intero cammino è rappresentato nel modo seguente:\\

\begin{gather}P = (c^1(p_{s,t}), c^2(p_{s,t}))\end{gather}
\begin{center}
	\textit{Dove $P$ è una soluzione}
\end{center}
\begin{gather}c^1(p_{s,t})=\sum_{(i,j)\in p}c^1_{i,j}\end{gather}
\begin{gather}c^2(p_{s,t})=\sum_{(i,j)\in p}c^2_{i,j}\end{gather}
Il nostro scopo è quello di \textbf{minimizzare} la ($1.2$) o la ($1.3$) e dunque ottenere lo ``spettro" di soluzioni che  è presente tra le due. Ad esempio considerando il caso succitato dove il primo peso rappresenta la lunghezza ed il secondo il pericolo, minimizzando la ($1.2$) otterremmo il percorso più breve, altrimenti il più sicuro.

\chapter{Algoritmi `Mono-criteria'}
In questo capitolo sono trattati esclusivamente i gli algoritmi che riguardano la ricerca di cammini minimi con un solo criterio di peso su ogni arco. L'analisi si concentra sull'implementazione e l'ottimizzazione dell'algoritmo di Dijkstra, spiegando alcune scelte implementative, e su di un altro celebre algoritmo in questo campo, l'\textit{A-star}

\section{Algoritmo di Dijkstra}
L'algoritmo di Dijkstra è molto celebre in letteratura e e tra chiunque abbia una conoscenza anche basica di algoritmi; è infatti molto usato per la ricerca dei cammini minimi in grafi connessi con archi aventi pesi positivi. Di seguito sono presenti brevi analisi di alcune interessanti implementazioni.


\begin{figure}
%\begin{BVerbatim}
	\verb|function DijkstraAlgorithm(source, target):|\\
	\verb|	    dist[source]| $\leftarrow$ 0\\
	\verb|	    create priorityQueue Q|\\
	\verb|	    q.put(source, dist[source])|\\
	\verb|	    while Q is not empty do|\\
	\verb|	        n| $\leftarrow$ \verb|Q.extract_min()|\\
	\verb|	        for each neighbor in v of n do|\\
	\verb|	            alt| $\leftarrow$ \verb|dist[n] + lenght(n, v)|\\
	\verb|	            if alt < dist[v] do|\\
	\verb|	                dist[v]| $\leftarrow$ \verb|alt|\\
	\verb|	                prev[v]| $\leftarrow$ \verb|n|\\
	\verb|	                Q.put(v, alt)|\\
	\verb|	    return dist, prev|\\
%\end{BVerbatim}

\caption{Pseudocodice dell'Algoritmo di Dijkstra (list of candidate)}
\label{fig:dijkstraLoC}
\end{figure}

\subsection{One to All}
Questa implementazione è utile in caso si volessero trovare tutti i percorsi brevi da un nodo sorgente $s\in N$ ad ogni altro nodo del grafo, dunque non si ferma finché ogni nodo del grafo (raggiungibile da $s$) non vien visitato. A livello implementativo il nodo sorgente è realizzato in modo da contenere un dizionario contenente ogni nodo raggiunto, utilizzando come chiave l'indice del nodo e come valore la distanza (ovvero la somma dei pesi degli archi) minima che ha da $s$.

Implementando una coda di priorità si raggiunge una complessità di $O((|N|+|A|)\log_2(|N|))$ dove $N$ è il numero dei vertici del grafo, mentre $A$ è il numero degli archi. Il caso peggiore, dove $A>>N$, raggiunge una complessità di $O(|A|\log_2(|N|))$.

\subsection{One to One}
A differenza della precedente, questa implementazione si concentra sul classico algoritmo di Dijkstra; non va quindi a visitare ogni singolo nodo del grafo bensì si fermerà quanto avrà raggiunto un nodo specifico $t \in N$. Non implementando una coda di priorità, andrà ad interrogare ogni nodo non visitato del grafo ad ogni ciclo, costruendo così il percorso nodo per nodo. Questo procedimento è indubbiamente esoso, infatti la sua complessità computazionale è $O(|N^2|)$.

\subsection{List of Candidate}
Questa ultima versione dell'algoritmo di Dijkstra (di cui è possibile leggere lo pseudocodice in fig.\ref{fig:dijkstraLoC}) utilizza una coda di priorità particolare: gli elementi di questa coda infatti vengono aggiornati ad ogni ciclo. Considerano i nodi vicini di ogni nodo che viene visitato ed utilizza la loro distanza come valore di priorità; ogni volta che un nodo viene visitato viene anche rimosso dalla coda. Questa implementazione interroga molti meno nodi rispetto alle precedenti versioni, ma nonostante questo ha lo stesso caso peggiore di complessità dell'algoritmo `\textit{One to All}': $O((|N|+|A|)\log_2(|N|))$

\section{``A Star''}
L'algoritmo \textit{A star} (conosciuto anche come A*) può essere considerata un'estensione dell'algoritmo di Dijkstra,poiché riesce ad ottenere una migliore performance ed accuratezza usando l'euristica \footnote{\url{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}}. Per determinare in che modo A* deve estendere i suoi percorsi, necessita di minimizzare la seguente equazione:

$$ f(n) = g(n) + h(n)$$   
Dove:
\begin{itemize}
	\item $n$ è il prossimo nodo del cammino
	\item $g(n)$ è il costo che ha accumulato il percorso dall'inizio (nodo $s$) fino al nodo $n$
	\item $h(n)$ è la funzione euristica
\end{itemize}
La funzione euristica, in questo caso, è la distanza più breve tra $n$ ed il nodo finale ($t$) dunque \textit{la linea retta} o meglio la \textbf{distanza euclidea} che lo separa dal `target'. In questo caso la complessità computazionale è relazionata ad $h$ ed al numero di nodi esplorati per la costruzione del cammino minimo.
Dunque il caso peggiore è $O(|N|) \equiv O(b^d)$ dove $b$ è il numero medio dei successori per nodo e $d$ i nodi esplorati per trovare la soluzione.
\subsubsection*{dettagli implementativi}
Ad ogni iterazione:
\begin{enumerate}
	\item Il nodo con il valore minore di $f(n)$ è estratto dalla coda (implementata come una coda di priorità)
	\item Aggiorna i valori dei nodi vicini e li aggiunge alla coda in base alla priorità
	\item L'algoritmo prosegue finché non viene raggiunto l'obbiettivo
\end{enumerate}
La \textbf{Distanza Euclidea} tra due punti è: $$\sqrt{(i_x - t_x)^2 + (i_y - t_y)^2}$$
Dove $i$ è un nodo del grafo e $t$ è il nodo che vogliamo raggiungere, $x$ e $y$ rappresentano le coordinate Cartesiane (nei grafi di esempio utilizzati, dato che rappresentano delle città, vengono convertiti da latitudine e longitudine dei vari punti).

Dato che il calcolo della radice quadrata è molto costoso in termini di tempo,è necessario trovare un modo per evitare di ripetere questa operazione in caso un singolo nodo venga visitato più volte (nell'implementazione utilizzata viene salvato nel nodo e quindi non viene più ricalcolato).


\begin{figure}
\verb|function DijkstraAlgorithm(source, target):|\\
\verb|    score[source]| $\leftarrow 0$\\
\verb|    create priorityQueue Q|\\
\verb|    q.put(source, score[source])|\\
\verb|    while Q is not empty do|\\
\verb|        n| $\leftarrow$ \verb|Q.extract_min()|\\
\verb|        for each neighbor v of n do|\\
\verb|            if v not visited do|\\
\verb|                tmpScore| $\leftarrow$ \verb|score[n] + lenght(v, n)|\\
\verb|                if tmpScore < score[v] do|\\
\verb|                    if euclidean[v] is None do|\\
\verb|                        euclidean[v]| $\leftarrow$ \verb|calcEuclidean(v, target)|\\
\verb|                score[v]| $\leftarrow$ \verb|tmpScore|\\
\verb|                prev[v]| $\leftarrow$ \verb|n|\\
\verb|                Q.put(v, tmpScore)|\\
\verb|    return score, prev|\\
	\caption{Pseudocodice dell'Algoritmo A*}
	\label{fig:Astar}
\end{figure}
\section{Analisi dei Risultati}
Di seguito sono presenti tabelle e figure che mostrano le caratteristiche degli algoritmi trattati nel capitolo. Le informazioni riguardo ad i grafi utilizzati per i test possono essere trovate nel capitolo 5, dedicato ai dettagli implementativi.
\subsection{Performance a Confronto}

\begin{table}
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{monoCriteriaOutput1di2.png}		
	\end{figure}
	\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{monoCriteriaOutput2di2.png}		
\end{figure}
		\caption{Performance of the mono-criteria algorithms (generate with tkinter library)}
		\label{tab:monoCriteriaOutput}
\end{table}
La tabella \ref{tab:monoCriteriaOutput} mostra alcune performance degli algoritmi trattati sulla mappa di Parigi, prendendo differenti punti di partenza e di arrivo, classificandoli in base al numero di nodi visitati (\textit{small, medium, big}).Ovviamente il tempo di esecuzione dell'algoritmo \textit{one to all} è costante, poiché comunque visita tutti i nodi del grafo, ma è interessante vedere come rimanga più veloce dell'algoritmo \textit{one to one}. Riguardo a gli altri due algoritmi (lista dei candidati e A*), il secondo è indubbiamente più vantaggioso del primo, ma la sua velocità di esecuzione è legata alla funzione euristica, quindi al calcolo della distanza euclidea, in un altro ambiente potrebbe non risultare egualmente vantaggioso.

\subsection{Nodi Visitati}

I vari algoritmi trattati visitano i nodi in maniera differenti: ovviamente l'algoritmo \textit{one to all} visiterà, come già detto, tutti nodi raggiungibili, l'algoritmo \textit{one to one} e \textit{list of candidate} visitano li stessi nodi, il secondo lo fa semplicemente molto più velocemente; l'algoritmo \textit{A*} invece visita i nodi in una maniera particolare (ovviamente dipendente dalla funzione euristica utilizzata). Questo infatti esplora un minor numero di nodi, che si traduce in un modesto risparmio di tempo di ricerca.
\\
Nelle seguenti immagini si possono vedere le differenze, a livello di ricerca, dei due algoritmi. L'algoritmo di Dijkstra nel visitare i nodi crea una specie di circonferenza attorno al nodo iniziale, al contrario dell'A-star il quale sembra quasi seguire il cammino minimo, creando una sorta di forma ovaleggiante, tra il nodo sorgente e destinazione, attraversata dal cammino minimo.

\begin{figure}[H]
	\textbf{\textit{Legend}:}
	\begin{itemize}
		{\small 		\item \textbf{Blu}: Nodi del grafo.
			\item \textbf{Giallo}: Nodi visitati.
			\item \textbf{Verde}: Nodo sorgente.
			\item \textbf{Nero}: Nodo terminale.
			\item \textbf{Linea rossa}: Cammino minimo.}
	\end{itemize}
	\centering
	%	\begin{minipage}[b]{\textwidth}
	\includegraphics[width=\textwidth]{mapOutput/2070-15426LoC.png}
	\label{fig:ListOfCandidate1}
	%	\end{minipage}
	%	\hfill
	%	\begin{minipage}[b]{\textwidth}
	\includegraphics[width=\textwidth]{mapOutput/2070-15426A_Star.png}
	\label{fig:A_Start1}
	%	\end{minipage}
	Source: 2070 $\to$ Target: 15426\\Map: Paris
\end{figure}
\begin{figure}[H]
	\centering
	\begin{minipage}[b]{\textwidth}
		\includegraphics[width=\textwidth]{mapOutput/2000-2689LoC.png}
		\label{fig:ListOfCandidate2}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{\textwidth}
		\includegraphics[width=\textwidth]{mapOutput/2000-2689A_Star.png}
		\label{fig:A_Start2}
	\end{minipage}
	Source: 2000 $\to$ Target: 2689\\Map: Paris
\end{figure}
\begin{figure}[H]
	\centering
	\begin{minipage}[b]{\textwidth}
		\includegraphics[width=\textwidth]{mapOutput/1000-1510BerlinLoC.png}
		\label{fig:ListOfCandidate3}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{\textwidth}
		\includegraphics[width=\textwidth]{mapOutput/1000-1510BerlinA_Star.png}
		\label{fig:A_Start3}
	\end{minipage}
	Source: 1000 $\to$ Target: 1510\\Map: Berlin
\end{figure}


\chapter{Algoritmi `Bi-criteria'}
In questo capitolo si andrà più nello specifico ad analizzare il problema ed a studiare alcune soluzioni; per poi valutarle in base ai risultati ottenuti. Tenendo in mente le espressioni matematiche formulate nel capitolo precedente possiamo soffermarci su alcune definizioni importanti:

\theoremstyle{definition}
\newtheorem{definition}{Definizione}
\begin{definition}{Concetto di Dominanza}\\
	Siano $X=(c^1(p_{s,t}),c^2(p_{s,t}))$, $Y=(c'^1(p_{s,t}),c'^2(p_{s,t}))$ due possibili cammini distinti da un nodo $s \in N $ ad un nodo $t \in N$. Si dice che $X$ \emph{domina} $Y$ se e solo se $c^1(p_{s,t}) < c'^1(p_{s,t}) \wedge c^2(p_{s,t}) < c'^2(p_{s,t})$.\\
	In questo caso X è detta \textbf{soluzione accettabile} (al contrario Y non verrebbe in alcun caso presa in considerazione).
\end{definition}

\theoremstyle{definition}
\begin{definition}{Inviluppo Convesso delle soluzioni}\\
	Sia $S$ un inseme di soluzioni accettabili, l'inviluppo convesso (conosciuto anche come \textit{Convex hull}) di $X$ è il più piccolo insieme convesso contenente X. Dato che consideriamo due dimensioni per il calcolo del percorso, ci troviamo in uno spazio euclideo a due dimensioni. L' inviluppo convesso può quindi essere definito dalla seguente equazione:
	\begin{equation}\label{eq:convex hull}
		\alpha \cdot c^1_{(p_{s,t})} + (1-\alpha)\cdot c^2_{(p_{s,t})} = k
	\end{equation}
	\begin{center}
		Dove $k$ è una costante e $\alpha \in \{0, 1\}$.\\
	\end{center}
\end{definition}

\theoremstyle{definition}
\begin{definition}{Fronte di Pareto}\\
	Il fronte di Pareto è l'insieme delle soluzioni ottimali, ovvero l'insieme di tutti i cammini \textit{non-dominati}. Una soluzione può far parte del fronte di Pareto senza dominare altre soluzioni e senza essere compreso all'interno dell'inviluppo convesso delle soluzioni.
\end{definition}

\section{Dijkstra applicato ad un problema Bi-criteria}
Partendo dalla definizione classica di \textit{grafo} è possibile fare un'astrazione e scrivere $G = (N,V, C)$, dove $C$ è l'insieme dei costi. La suddetta definizione, quindi, +possibile estenderla ad un ``grafo bi-critera" come $G = (N,V, C^1, C^2)$, dove $C^1$ e $C^2$ sono gli insiemi dei soliti due pesi, ma in questo modo l'algoritmo di Dijkstra non è applicabile. Utilizzando la \ref{eq:convex hull} è possibile ridurre questa nuova definizione come  a $G = (N,V, \alpha*C^1_i + (1-\alpha)C^2_i)$ e, considerando che la \ref{eq:convex hull} ha come risultato un elemento costante, sarà possibile un approccio simile agli algoritmi affrontati nel precedente capitolo.\\
L'algoritmo di Dijkstra `\textit{list of candidate}'è il più vantaggioso, dato che non è possibile, in questo caso generico, individuare un funzione euristica che risolva in maniera ottimale l'equazione.
\\

\'E facilmente comprensibile che utilizzando la \ref{eq:convex hull}, in base al valore dato ad $\alpha$ otterremo un cammino che minimizza più un peso piuttosto che l'altro. Per esempio, ponendo il primo peso come \textit{tempo di latenza} ed il secondo come \textit{consumo energetico}, più il valore di $\alpha$ so avvicina a $0$ più troveremo un percorso con una grande latenza ma un basso consumo energetico, mentre se questo valore si avvicina a $1$ allora il percorso avrà meno latenza ma un consumo energetico inferiore.
\\
La complessità computazionale è la stessa dell'algoritmo di Dijkstra mostrato precedentemente. Di seguito è riportato il codice che descrive questo ragionamento.

\begin{figure}
%	\begin{BVerbatim}
\verb|function DijkstraAlgorithm(source, target, alpha):|\\
\verb|	score[source]| $\leftarrow 0$\\
\verb|	create priorityQueue Q|\\
\verb|	Q.put(source, score[source])|\\
\verb|	while Q is not empty do|\\
\verb|	    n| $\leftarrow$ \verb|Q.extract_min()|\\
\verb|	    for each neighbor v of n do|\\
\verb|	        alt| $\leftarrow$ \verb|alpha*firstW(n, v) + (1 - alpha)*secondW(n, v)|\\
\verb|	        alt| $\leftarrow$ \verb|alt + score[u]|\\
\verb|	        if alt < score[v] do|\\
\verb|	            score[v]| $\leftarrow$ \verb|alt|\\
\verb|	            prev[v]| $\leftarrow$ \verb|n|\\
\verb|	            Q.put(v, tmpScore)|\\
\verb|	return score, prev|\\
%	\end{BVerbatim}
	\caption{Pseudocodice dell'Algoritmo di Dijkstra utilizzato con due criteri}
	\label{fig:Dijkstra Bicrit}
\end{figure}

Poiché questo algoritmo ha alla base la formula dell'inviluppo convesso, significa che i suoi risultati andranno a creare la curva che ne concettualizza il significato. Vediamo di seguito.

\subsection{Implementazioni dell'algoritmo di Dijkstra con due criteri}
Per utilizzare l'algoritmo sopracitato ed ottenere un numero soddisfacente di risultati è necessario richiamarlo ogni volta con un diverso valore di $\alpha$.

\subsubsection{Iterazione Dijkstra bi-criteria}
Questa è un implementazione piuttosto basilare, si basa semplicemente sul richiamare l'algoritmo partendo con $\alpha$ uguale a $0$, per poi aumentarne il valore di un numero arbitrario chiamato \textbf{precisione}; se il risultato è differente da quello precedente allora il cammino viene salvato ed il valore di $\alpha$ dimezzato, altrimenti si prosegue, fino a che non si raggiunge $\alpha = 1$.
\\
Questa soluzione richiede un tempo di elaborazione in relazione alla precisione utilizzata, infatti più questa è piccola, più volte verrà richiamata la funzione, dunque si otterranno differenti risultati (\textit{soluzioni accettabili}); ma ciò significa anche che la funzione spesso darà dei risultati inutili, sprecando cicli preziosi.

\subsubsection{Dijkstra bi-criteria con ricerca binaria}
Questa è una versione un po' meno grezza della precedente, dato che utilizza un algoritmo di ricerca binaria. Viene eseguita la funzione almeno due volte, una con $\alpha = 0$, poi una con $\alpha = 0$; se generano risultati differenti allora il valore di $\alpha$ viene dimezzato, e così via finché non si trovano più soluzioni. Seppur più efficiente rispetto ad un'iterazione con alta precisione, in termini di tempo e di risultati trovati non risulta essere perfetto.
\\

Di seguito è presente una tabella che mostra i risultati tra due esecuzioni dell'iterazione dell'algoritmo bi-criteria di Dijkstra, con differenti precisioni, e l'implementazione con la ricerca binaria.\\

\begin{table}[h]                  %ambiente tabella
\centering                         %(serve per avere la legenda)
\textit{{\tiny Questi risultati sono stati calcolati sulla mappa di Parigi (vd. risorse), considerando come partenza il nodo avente indice 2000 e come nodo terminale quello di 2689}}
\begin{tabular}{ |p{4cm}||m{3cm}|p{3cm}|  }
	\hline
	Valore di $\alpha$ & PESO 1 & PESO 2 \\
	\hline
	\multicolumn{3}{|c|}{Iterazione con \textbf{precisione} = 0.2} \\
	\hline
	
	 $\alpha$ = 0   & 9231    &12827\\
	 $\alpha$ = 0.2 &   7153  & 12884\\
	 $\alpha$ = 0.7 & 6091 &  14230\\
	 $\alpha$ = 0.55 & 6317 &  13754\\
	 $\alpha$ = 0.875 &   5944  & 14824\\
	 $\alpha$ = 1 & 5840 & 16763 \\
	\hline
	\multicolumn{3}{|c|}{AVGtime: 2.112018585205078} \\ 
	\hline\hline
		\multicolumn{3}{|c|}{Iterazione con \textbf{precisione} = 0.05} \\
	\hline
	 $\alpha$ = 0   & 9231    &12827\\
	 $\alpha$ = 0.05 &   7153  & 12884\\
	 $\alpha$ = 0.525 & 6317 &  13754\\
	 $\alpha$ = 0.7125000000001 & 6091 &  14230\\
	 $\alpha$ = 0.8062500000004 &   6030  & 14430\\
	 $\alpha$ = 0.8531250000005  & 5944 & 14824 \\
	 $\alpha$ = 0.9265625000006  & 5874 & 15649 \\
	 $\alpha$ = 1  & 5840 & 16763 \\	
	\hline
		\multicolumn{3}{|c|}{AVGtime: 7.837886095046997} \\  
	\hline
\end{tabular}
\end{table}
\begin{table} [H]                  %ambiente tabella
	\centering
\begin{tabular}{ |p{4cm}||m{3cm}|p{3cm}|  }
	\hline
	Valore di $\alpha$ & PESO 1 & PESO 2 \\
	\hline
		\multicolumn{3}{|c|}{Dijkstra con ricerca binaria} \\
	\hline
  $\alpha$ = 1 & 5840  &  16763\\
  $\alpha$ = 0 & 9231  &  12827\\
  $\alpha$ = 0.5 & 7153  &  12884\\
  $\alpha$ = 0.75 & 6091  &  14230\\
  $\alpha$ = 0.625 & 6317  &  13754\\
  $\alpha$ = 0.875 & 5944  &  14824\\
  $\alpha$ = 0.812 & 6030  &  14430\\
  $\alpha$ = 0.937 & 5874  &  15649\\
  $\alpha$ = 0.9680000000001 & 5855  &  16199\\
  $\alpha$ = 0.9660000000001 & 5863  &  15959\\
  $\alpha$ = 0.9740000000001 & 5847  &  16493\\
	\hline
	\multicolumn{3}{|c|}{AVGtime: 4.851694107055664} \\ 
	\hline
\end{tabular}
\caption{Output dei due algoritmi di Dijkstra bi-criteria a confronto}
\label{table:dijkstra bicrit}
\end{table}
Da questi risultati è infatti possibile notare come una bassa precisione permette di avere un determinato insieme di risultati in tempi ragionevolmente bassi, differentemente si può dire dell'iterazione con precisione alta. Con la ricerca binaria è possibile ottenere un range abbastanza ragionevole di risultati in tempi discreti.


\section{Algoritmo di Label-setting}
Come precedentemente scritto, l'algoritmo di Dijkstra applicato a due criteri non è in grado di trovare tutte le soluzioni possibili (con qualsiasi livello di precisione), bensì solo quelle che compongono l'inviluppo convesso. Dunque se noi volessimo trovare un più amplio insieme di soluzioni non dominate, dunque se volessimo trovare il \textit{Fronte di Pareto} dobbiamo affidarci ad un algrotimo di Label-setting. Di seguito è presente un'esempio  di quanto detto, dove vengono messi a confronto le soluzioni trovate da Dijkstra applicato a due criteri e l'algoritmo trattato in questo capitolo. Nell'esempio vengono utilizzati la distanza ed il pericolo come valori che contraddistinguono i due pesi in questione. 
\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{graphDijkstraBicrit.png}
		\caption{Soluzioni trovate da \textit{Dijkstra bi-criteria con ricerca binaria}}
		\label{fig:graphBiDi}
	\end{minipage}
	%\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{graphLabelsetting.png}
		\caption{Soluzioni trovate dall'algoritmo \textit{Label-setting}}
		\label{fig:graphLabSet}
	\end{minipage}
	\textit{{\tiny Questo esempio è stato calcolato utilizzando la mappa di Parigi, coprendo il tragitto che va dal nodo 2000 al nodo 2689.}}
\end{figure}

Nel grafo in figura \ref{fig:graphLabSet} sono presenti solo alcuni punti appartenenti alla \textit{convex hull} (quadrati rossi), mentre nel grafico affianco snono presenti tutte le soluzioni ottenute con l'algoritmo di label-setting (punti gialli). Infatti, come è anche possibile vedere, nel grafico a destra alcuni punti gialli trovano corrispondenza in tutti i punti trovati nel grafico a sinistra. Le soluzioni trovate quindi dall'algoritmo di label-setting sono tutte accettabili, dunque il suo insieme di soluzioni è più completo.

\subsection{Implementazione}
Questo algoritmo è basato, da come si può intuire dal nome, sul creare e salvare appunto dei `\textit{label}' dove sono contenute le informazioni sul percorso che si affronta per andare da un nodo ad un altro del grafo. I label sono strutturati in questo modo: $$(peso1, peso2, propriet, pred, indicePropriet, indicePred)$$
I primi due parametri rappresentano i costi del cammino dal nodo sorgente, il terzo ed il quarto sono rispettivamente il nodo possessore del label ed il suo predecessore (o vero il nodo antecedente, da dove ``arriva" il cammino), gli ultimi due valori invece, utilizzati per il `\textit{backtracking}' del percorso, indicano la posizione del label in corrispondenza del loro nodo possessore e del loro predecessore.
\\

\begin{figure}[h]
%\begin{verbatim}
\verb|function DijkstraAlgorithm(source, target):|\\
\verb|    originLabel| $\leftarrow$ \verb|(0, 0, source, Null, 0, Null)|\\
\verb|    source.add(originLabel)|\\
\verb|    create priorityQueue Q|\\
\verb|    Q.put(orginLabel, priority())|\\
\verb|    while Q is not empty do|\\
\verb|        actualLabel| $\leftarrow$ \verb|Q.extract_min()|\\
\verb|        owner| $\leftarrow$ \verb|actualLabel[2]|\\
\verb|        for each neighbor v of owner do|\\
\verb|            firstW| $\leftarrow$ \verb|weightOne(owner, v) + actualLabl[0]|\\
\verb|            secondW| $\leftarrow$ \verb|weightTwo(owner, v) + actualLabel[1]|\\
\verb|            vIndex| $\leftarrow$ \verb|v.labelIndex()|\\
\verb|            predIndex| $\leftarrow$ \verb|owner.labelIndex()|\\
\verb|            label| $\leftarrow$ \verb|(firstW, secondW, v, owner, vIndex, predIndex)|\\
\verb|            if label is not dominated by v.labels() do			|	\\
\verb|                v.labelsAdd(label)    //rimuove i label dominati|\\
\verb|                if v is not target do|\\
\verb|                    Q.put(label, priority())|\\
%\end{verbatim}
	\caption{Pseudocodice dell'Algoritmo Label-setting}
\label{fig:LabelSetting}
\end{figure}


Come si può notare dalla prima parte dello pseudocodice, l'algoritmo subisce una grande influenza da parte dell'algoritmo di Dijkstra data la somiglianza. Ogni volta che un label viene calcolato si vano in contro a tre differenti casi:
\begin{enumerate}[label=\roman*.]
	\item Il label calcolato è dominato, dunque l'algoritmo lo scarta.
	\item Il label calcolato domina altri label, quindi lui viene aggiunto alla lista dei label mentre i dominati rimossi.
	\item Il label calcolato non domina e non viene dominato da nessuno, dunque viene aggiunto alla lista dei label.
\end{enumerate}

\subsubsection*{Esempio:}
\'E possibile fare un esempio di esecuzione dell'algoritmo osservando la figura \ref{fig:graphExample} patendo dal nodo 1. Come prima cosa verrà creato il label avente i seguenti valori: $(0,\ 0,\ 1,\ null,\ 0,\ null)$, poi, per ogni vicino (2 e 3), i label: $(3,\ 4,\ 2,\ 1,\ 0,\ 0)$ e $(5,\ 3,\ 3,\ 1,\ 0,\ 0)$ e inseriti all'interno della coda. Viene di seguito estratto il label che ha come possessore il nodo 2 e poi continua in questo modo fino ad arrivare al nodo 6. Ogni nuovo label trovato viene quindi studiato per capire se domina, è dominato o semplicemente è una soluzione accettabile.

\subsubsection{Complessità computazionale}
Il caso peggiore che potrebbe essere incontrato dall'algoritmo è esplicato dalla figura \ref{fig:worstCaseLabelSetting}, ovvero la remota possibilità di trovare una soluzione accettabile e non dominante ad ogni iterazione, dunque dove il primo peso è zero ed il secondo è più grande del corrispettivo peso che lo precede:

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{labelSettingComplexity.png}
	\caption{Caso peggiore dell'algoritmo di label-setting}
	\label{fig:worstCaseLabelSetting}
\end{figure}

\'E possibile dunque affermare che la complessità di questo algoritmo è $O(2^{n-1})$ dove $n$ è il numero di nodi. 

\section{Algoritmo di Label-setting con minoranti pregressi}
Volendo migliorare i tempi di esecuzione dell'algoritmo di label-setting si può pensare di affiancare alla sua computazione una fase di \textit{pre-elaborazione}. Questa fase può essere effettuata sfruttando l'algoritmo di Dijkstra, applicato a due criteri, visto precedentemente. Il vantaggio risiederebbe nella possibilità di conoscere alcuni dei label più vantaggiosi di diversi nodi sparsi lungo il percorso, in questo modo sarà possibile, per l'algoritmo di label-setting, eliminare in anticipo i cammini che risultano avere una proiezione dominata.\\
Dunque, per svolgere il ragionamento sopracitato si prendono due nodi, come sempre $s$ e $t$ entrambi in $\in N$, e si esegue l'algoritmo di Dijkstra bi-criteria due volte, la prima con $\alpha = 0$, al seconda con $\alpha = 1$, minimizzando così entrambi i pesi. Al termine di ciò siamo a conoscenza del label, appartenente a $t$ con il primo peso più piccolo ed il secondo peso più grande e del label con il peso numero due più piccolo ed il primo più grande; ma non solo, in questo modo troviamo anche tutti i label che appartengono al percorso che porta ai label di $t$; presupponendo che questi appartengano ai `fronti di pareto' dei nodi del percorso, l'algoritmo può capire se i label in cui si va incontro durante la computazione dell'algoritmo di label-setting sono dominati oppure no

\subsection{Algoritmo di label-setting con minoranti pregressi invertito}
\'E possibile realizzare un'altra implementazione, che comprende una fase di \textit{pre-elaborazione}, simile alla precedente. Considerando sempre $s$ e $t$, come nodi rispettivamente di partenza e di arrivo, si esegue l'algoritmo di Dijkstra bi-criteria al contrario, ovvero da $t$ a $s$, sempre con $\alpha = 0$ e $\alpha = 1$. Similmente al caso precedente si ricavano alcuni dei label non dominati per ogni nodo del cammino, ma questa volta a partire dal fondo. Dunque sommando il valore di uno dei pesi trovato nella fase di pre-elaborazione con il corrispettivo valore calcolato dall'algoritmo in esecuzione, si può trovare la sua proiezione e dedurre se questa sarà dominata o meno.\\
Il concetto, molto complesso a parole, ma in realtà basilare nel ragionamento, può essere riassunto e semplificato in questo modo:
\begin{itemize}
	\item[-] $pp=$ miglior ``peso 1" del percorso (calcolato nella pre-elaborazione).
	\item[-] $pn =$ miglior ``peso 1" del nodo ( `` ).
	\item[-] $ap =$ valore \textit{attuale} del ``peso 1" calcolato fino a quel momento dall'algoritmo.
	\item[-] $res =$ proiezione del peso da quello specifico nodo.
\end{itemize}
$$res = pd - nd  + ad$$

Poiché siamo a conoscenza delle due soluzioni (sia con $\alpha = 0$ che $ = 1$) calcolate con Dijkstra, è possibile constatare se la proiezione dei label per ogni peso.\\
Questa implementazione funziona però unicamente su grafi non orientati, al contrario della versione ``non invertita".

\section{Algoritmo Bidirezionale Bi-criteria}%cita
In letteratura gli algoritmi bidirezionali sono molto elogiati per la loro capacità di accelerare la ricerca all'interno di una rete, questa sezione si concentrerà dunque sull'analisi di un algoritmo bidirezionale in grado di calcolare il fronte di Pareto. L'idea alla base di questo algoritmo è di alternare una ricerca normale, quindi dal nodo di partenza al nodo finale, ad una invertita, ovvero dal nodo finale a quello iniziale. \'E facile dedurre che anche questo algoritmo è efficace unicamente in grafi non orientati, altrimenti troverebbe dei cammini non percorribili, inoltre le sue performance sono dipendenti anche dalla configurazione del grafo preso in considerazione: poiché il livello di accelerazione della ricerca potrebbe variare in base a caratteri quantitativi e qualitativi della rete; i grafi presi in considerazione per i test sono piuttosto uniformi ed equilibrati, dunque si avrà una discreta accelerazione.\\
L'alternanza tra la ricerca all'avanti e quella all'indietro può essere implementata in diversi modi, in questa ricerca, per semplicità, vengono equamente alternati uno alla volta, ma sono possibili diverse soluzioni, come ad esempio considerare il label più piccolo (a livello lessicografico) indifferentemente dalla sua direzione di ricerca. Differenti scelte potrebbe avere un impatto sulle performance, ma sarebbero comunque irrilevanti rispetto al guadagno,in termini di tempo, che si andrebbe ad ottenere.\\
Abbiamo detto che la ricerca viene effettuata in due direzioni, l'andamento di queste due ricerche separate è simile a quello di un algorito unidirezionale, quindi nuovi label vengono calcolati a partire dai vicini di un nodo ed aggiunti al set dei label di questi. Si avranno due set, uno per ogni direzione, dove i label dominati vengono rimossi per far posto a quelli dominanti. Quando si va ad investigare un nodo in cui sono presenti dei label ``provenienti" dalla direzione opposta allora si combinano i due percorsi e si effettuano le dovute valutazioni di dominanza, in caso il cammino trovato risulta essere una soluzione accettabile viene aggiunto alla lista delle soluzioni. Ogni qual volta vengano combinati dei percorsi che portano ad una soluzione accettabile, tutte le eventuali soluzioni dominate da quest'ultima vengono rimosse dalla lista che contiene i risultati (ovvero quelli che andranno a comporre il fronte di Pareto).

\subsection{Implementazione}
Come già detto l'algoritmo riprende dei concetti ormai appurati, come ad esempio la struttura dei label, che rimangono invariati rispetto agli algoritmi precedenti, e l'andamento dell'algoritmo in relazione alla singola direzione.\\

La caratteristica più rilevante riguarda la \textbf{condizione di stop}: mentre in tutte le implementazioni viste fin'ora gli algoritmi terminavano nel momento in cui la lista contenente tutti i label temporanei si svuotava, qui il \textit{loop} si interrompe quando la somma dei label più piccoli delle liste (in entrambe le direzioni) risulta un valore dominato da almeno un elemento contenuto nella lista dei risultati; in poche parole:\\
L'algoritmo termina quando $[\min_i(Q_f) + \min_i(Q_b)]$ è dominato da un qualsiasi $R\in L_{results}$, dove $f$ e $b$ abbreviano \textit{forward} e \textit{backward}.\\
L'immagine \ref{fig:bidirectional} mostra lo pseudocodice relativo.



\subsubsection{Caso particolare della condizione di stop}
Considerando $C_i$ un cammino (ricongiunto nel nodo $i$) che risulta essere una soluzione accettabile del percorso, ma che non è stato ancora trovato, implica che $C_i$ nonè dominato da nessuna soluzione $R \in L_{result}$, quindi anche da nessun $r_i$ (relativo a quello specifico nodo). Per la condizione di stop $r_i \leq [\min_i(Q_f) + \min_i(Q_b)]$ allora:

$$	\exists i: C_i = c^f_i+c^b_i < r_i \leq [\min_i(Q_f) + \min_i(Q_b)]$$

Dunque
	\begin{equation}\label{eq:bidirectional}
\exists i:c^f_i+c^b_i < [\min_i(Q_f) + \min_i(Q_b)]
\end{equation}
Dato che $C_i$ non è ancora stato trovato, significa che $\forall i:c^f_i\geq \min_i(Q_f) \lor c^b_i \geq \min_i(Q_b)$ , ma è impossibile che accadano entrambi contemporaneamente, altrimenti il cammino sarebbe dominato ed andrebbe contro la (\ref{eq:bidirectional}). Dunque $\exists i:c^f_i\geq \min_i(Q_f) \land (c^b_i < \min_i(Q_b) \lor c^b_i = \min_i(Q_b)) \ \lor \ ( c^f_i < \min_i(Q_f) \lor c^f_i = \min_i(Q_f)) \land c^b_i \geq \min_i(Q_b)$
\\

Considerando solo uno dei due casi, poiché l'altro deducibile allo stesso modo, si assume che
$$\exists i:( c^f_i < \min_i(Q_f) \lor c^f_i = \min_i(Q_f)) \land c^b_i \geq \min_i(Q_b)$$
Quindi il label che parte dal nodo terminale non è stato ancora calcolato, mentre quello che parte dal sorgente sì, di conseguenza sono stati calcolati anche i label dei suoi vicini (altrimenti non sarebbe $< \min_i(Q_f)$). Sia $C^b$ il label che andrà a comporre sul nodo $i$ il cammino finale, consideriamo il predecessore e chiamiamolo $C'^b$. Al contempo sia $C^f$ il label sul nodo $i$ proveniente dall'origine, quindi il nodo che possiede $C^f$ è lo stesso che possederebbe $C^b$. $C^f$ è un label che è stato calcolato e visitato (il che significa che è \textit{permanente}), considero dunque $C'^f$ un label calcolato \textbf{a partire} da $C^f$, quindi appartenente ad un nodo vicino; quest'ultimo label può essere sia un label permanente, che \textbf{temporaneo}, ovvero solamente calcolato, ma non ancora visitato. Al contrario il label $C'^b$, non essendo ancora stato neanche calcolato $C^b$, può essere temporaneo o non ancora calcolato. Analizzando le varie possibilità si ricade in quattro diversi casi:

\begin{description}
	\item[$C'^f$ è permanente e $C'^b$ è temporaneo:]  Il cammino viene trovato dall'algoritmo e la soluzione aggiunta al fronte di Pareto.
	\item[$C'^f$ è permanente e $C'^b$ non calcolato:] Ci riconduce alla situazione iniziale dove $\exists i:( c'^f_i < \min_i(Q_f) \lor c'^f_i = \min_i(Q_f)) \land c'^b_i \geq \min_i(Q_b)$.
	\item[$C'^f$ e $C'^b$ sono temporanei:] Il cammino non è ancora stato trovato, ma entrambi i label sono stati calcolati, ci si riconduce quindi ad un caso simile al primo.
	\item[$C'^f$ è temporaneo e $C'^b$ non calcolato:] Essendo il label all'interno della coda, significa che $C'^f \geq min_i(Q_f)$, allo stesso modo $C'^b \geq min_i(Q_b)$ poiché non è stato neanche calcolato. Quest'ultimo caso va contro all'equazione \ref{eq:bidirectional}, quindi non esiste una soluzione che può far parte del fronte di Pareto.
\end{description}

\begin{figure}[H]
	%\begin{verbatim}
	\verb|function BidirectionAlgorithm(source, target):|\\
	\verb|    create priorityQueue Q[f]|\\
	\verb|    create priorityQueue Q[b]|\\
	\verb|    create list L|$_{result}$\\
	\verb|    originLabel| $\leftarrow$ \verb|(0, 0, source, Null, 0, Null)|\\
	\verb|    source.add(originLabel)|\\
	\verb|    Q[f].put(originLabel)|\\
	\verb|    targetLabel| $\leftarrow$ \verb|(0, 0, source, Null, 0, Null)|\\
	\verb|    source.add(targetLabel)|\\
	\verb|    Q[b].put(targetLabel)|\\
	\verb|    while [min|$_i$\verb|(Q[f]) + min|$_i$\verb|(Q[b])]|\\\verb|                        is not dominated by any| R$\in L_{results}$ \verb|do|\\
	\verb|        d| $\leftarrow$ \verb|getDirection()    //forward o backward|\\
	\verb|        actualLabel| $\leftarrow$ \verb|Q[d].extract_min()|\\
	\verb|        owner| $\leftarrow$ \verb|actualLabel[2]|\\
	\verb|        for each neighbor v of owner do|\\
	\verb|            firstW| $\leftarrow$ \verb|weightOne(owner, v) + actualLabl[0]|\\
	\verb|            secondW| $\leftarrow$ \verb|weightTwo(owner, v) + actualLabel[1]|\\
	\verb|            vIndex| $\leftarrow$ \verb|v.labelIndex()|\\
	\verb|            predIndex| $\leftarrow$ \verb|owner.labelIndex()|\\
	\verb|            label| $\leftarrow$ \verb|(firstW, secondW, v, owner, vIndex, predIndex)|\\
	\verb|            if label is not dominated by v.labels(d) do			|	\\
	\verb|                v.labelsAdd(label, d)   //rimuove i label dominati|\\
	\verb|                Q[d].put(label)|\\
	\verb|                if v.labels(!d) is not empty do   //!d = direzione opposta|\\
	\verb|                    result| $\leftarrow$ \verb|combine(label, v.labels(!d))|\\
	\verb|                    L|$_{results}$\verb|.addResults(results)|
	%\end{verbatim}
	\caption{Pseudocodice dell'Algoritmo bidirezionale}
	\label{fig:bidirectional}
\end{figure}
 
\section{Analisi dei risultati}
Di seguito vengono effettuati dei test degli algoritmi trattati nel capitolo su grafi di diverso tipo e dimensioni.

\begin{tabular}{ |p{2cm}||p{2cm}|p{3cm}|p{2cm}|p{3cm}|  }
	\hline
	Nodo di arrivo & Soluzioni trovate & tempo impiegato (sec) & Soluzioni trovate & tempo impiegato (sec) \\
	\hline
	 & \multicolumn{2}{|c|}{Dijkstra Iter. \textbf{prec.} = 0.05} &
	\multicolumn{2}{|c|}{Dijkstra binary search} \\
	\hline
	
	10 & 5 & 10.06989 & 5 & 6.02213\\
	100 & 23 & 32.07635  & 12 & 11.89208\\
	500 & 84 & 96.60857 & 23 & 82.71155\\
	700 & 123 & 210.80490 & 27 & 23.74903\\
	5000 & 593 & 664.78488 & 46 & 23.74327\\	
	\hline
	
\end{tabular}
\\
\\

\begin{tabular}{ |p{2cm}||p{2cm}|p{3cm}|p{2cm}|p{3cm}|  }
	\hline
	Nodo di arrivo & Soluzioni trovate & tempo impiegato (sec) & Soluzioni trovate & tempo impiegato (sec) \\
	\hline
	&\multicolumn{2}{|c|}{Label-setting} &  \multicolumn{2}{|c|}{bidirectional algorithm} \\
	\hline
	10 & 10 & 0.00040 & 10 & 0.00053 \\
	100  & 116 & 1.05214 & 78 & 0.12738 \\
	300  & 663 & 70.93244 & 227 & 2.4432 \\
	500 & 1867 & 925.68206 & 167 & 29.14023 \\
	700 & 3278 & 4795.59632 & 429 & 141.73064\\
	
	\hline
	
\end{tabular}

\chapter{Considerazioni Personali}
Nel seguente capitolo parlerò dei miei pensieri e delle esperienze personali riscontrate durante la stesura di questa tesi triennale.
\section{Idee Scartate}
\subsubsection*{Algoritmo Genetico}
L'idea iniziale era di trovare una soluzione in un tempo non polinomiale ad un problema polinomiale. L'idea è stata scartata, anche sotto suggerimento del relatore, poiché ci si sarebbe approcciati al problema in una maniera eccessivamente ed inutilmente complessa,inoltre è stato dimostrato in 
%citazione.
non essere una soluzione molto performante.
\subsubsection*{Algoritmo bidirezionale con l'utilizzo di thread}
Nonostante avessi già implementato l'algoritmo bidrezionale, ho scartato questa idea poiché sarebbe stato inutile paragonarla agli altri algoritmi.
\section{Possibili Applicazioni}
Molti esempi su come sia possibile applicare un algoritmo che lavora su grafi con due pesi sono già stati fatti nel testo, si è parlato di ``eco-path", ovvero la ricerca di cammini minimi in un ambiente dove è importante il risparmio di energia, oppure, si può calcolare un percorso stradale che come valori, invece di considerare la classica distanza e velocità media, considera il tempo medio di percorrenza e il consumo di carburante (e.g. una strada in salita, oppure una strada dove ci si ferma e si riparte molto spesso consuma più carburante di una più lineare, ma più lunga). O ancora, se considero il primo peso come la distanza o il tempo ed il secondo come la pericolosità di un pericolo potrei ottenere diversi percorsi montani con diversi livelli di difficoltà,dove una persona, in base alle sue conoscenze può decidere dove andare. Oltre a questi esempi di pura immediatezza, gli algoritmi analizzati possono essere utilizzati nel campo del ``\textit{decision making''}, piuttosto che in algoritmi per l'intelligenza artificiale. Nel campo della ricerca operativi, quindi l'ottimizzazione, può essere applicato al problema dei trasporti. Le possibilità sono enormi.
\section{Difficoltà incontrate}
Le difficoltà principali sono state riscontrate soprattutto nella stesura degli algoritmi in relazione con le mappe che mi sono state fornite (vd. ch5). Inoltre l'implementazione degli algoritmi con minoranti sono stati piuttosto macchinosi e non immediati, seppur il ragionamento dietro il loro sviluppo sia basilare. Nonostante nelle mappe di Parigi e di Berlino conoscessi già alcuni cammini minimi (poiché mi sono stati forniti insieme alle mappe), testare gli algoritmi che lavorano unicamente su grafi non orientati (bidirezionale e minorante invertito) è stato piuttosto complesso. Per verificarli ed effettuare i primi ragionamenti, prima di iniziare a scrivere il codice, ho dovuto fare diverse congetture e ragionamenti su carta, che mi hanno impegnato non poco tempo.

\section{Sviluppi futuri}
Sarebbe interessante approfondire l'argomento considerando algoritmi che studiano i cammini minimi in grafi con più di due criteri, i cosiddetti ``\textit{Multi Objective Shortest Path Problems}" molto studiati in letteratura. Le basi in realtà ci sono già, poiché l'algoritmo di Label-setting può essere facilmente esteso per lo studio in differenti criteri, stesso discorso vale per l'algoritmo bidirezionale. Per quanto riguarda l'algoritmo di Dijkstra applicato a più criteri il discorso cambia, poiché la formula applicabile diverrebbe piuttosto complessa all'aumentare dei criteri per i cammini.


\chapter{Dettagli implementativi}
Immagini, codice sorgente e mappe (nodi e archi) possono essere liberamente recuperate dal repository \footnote{\url{https://bitbucket.org/AndreaRossolini/bicriteria-algorithm/}}.

\section{Informazioni sui grafi}
I grafi delle mappe di Parigi e di Berlino mi sono state gentilmente fornite dal direttore dell'università ``Polytech Tours" (Univeristé de Tours, Francia). I punti delle mappe sono numerati e sono su sistema di riferimento spaziale WGS84 (EPGS:4326 - lo stesso utilizzato da Google Maps), mentre gli archi direzionati hanno dei valori casuali.\\
La mappa della provincia di Bologna e del comune di Cesena sono state invece fornite dall'azienda Optit, che opera a Cesena. Queste mappe sono il risultato di un ritaglio fatto da parte dell'azienda e poi inviatomi tramite diversi file in formato `.shp' (3 file per mappa, un file conteneva gli id degli archi e la loro lunghezza, uno i punti di arrivo, di partenza e se la strada è a senso unico o meno, l'ultimo file conteneva i punti nella mappa, con riferimento spaziale EPSG:32632). Il formato è stato convertito e le coordinate ritradotte per avere lo stesso riferimento con Parigi e Berlino.\\
Inoltre per effettuare alcuni test sono state generate casualmente dei grafi, è possibile consultare il file `.py' che le gestiva.
La mappa di Parigi è composta da $\sim 30000$ nodi e $\sim 64500$ archi, quella di Berlino da $\sim 60000$ nodi e $\sim 150000$ archi, la provincia di Bologna $\sim 40000$ nodi e $\sim 100000$ archi, Cesena invece possiede $\sim6000$ nodi e $\sim 16000$ archi.\\
I grafi generati in maniera `randomica' vengono descritti dal testo o dalle didascalie quando utilizzati nei test. 

\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} Primo oggetto bibliografia.
\bibitem{K2} Secondo oggetto bibliografia.
\bibitem{K3} Terzo oggetto bibliografia.
\bibitem{K4} Quarto oggetto bibliografia.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Ringraziamenti}
\thispagestyle{empty}
Qui possiamo ringraziare il mondo intero!!!!!!!!!!\\
Ovviamente solo se uno vuole, non \`e obbligatorio.
\end{document}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliografia bonus:
%P. E. Hart, N. J. Nilsson, B. Raphael: A Formal Basis for the Heuristic Determination of Minimum Cost Paths, IEEE Transactions on Systems Science and Cybernetics SSC4 (2), pp. 100?107, 1968.
% P. E. Hart, N. J. Nilsson, B. Raphael: Correction to "A Formal Basis for the Heuristic Determination of Minimum Cost Paths", SIGART  Newsletter, 37, pp. 28?29, 1972.
% N. J. Nilsson, Principles of Artificial Intelligence, Tioga Publishing Company, Palo Alto, California, 1980.
