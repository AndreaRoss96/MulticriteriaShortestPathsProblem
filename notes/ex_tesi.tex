%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come è à
                                        %   si può usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   però con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{array}
\usepackage{graphicx}
\usepackage{algorithm,algpseudocode}

\usepackage{imakeidx}

\usepackage{blindtext}

\graphicspath{ {Report/img/} }
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{sil-la-ba-zio-ne pa-ren-te-si}%serve per la sillabazione: tra parentesi 
					   %vanno inserite come nell'esempio le parole 
%					   %che latex non riesce a tagliare nel modo giusto andando a capo.

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
%



\begin{document}
	
	\begin{abstract}
		Questa tesi si pone l'obbiettivo di affrontare ed analizzare un problema di \textit{pathfinding} partendo da uno studio su di alcuni algoritmi per la ricerca del percorso più breve su classici grafi, per poi, dopo alcune ottimizzazioni, lavorare con grafi che utilizzano due pesi per ogni arco, considerando l'insieme di soluzioni più soddisfacenti.
		
		Dato che, lo studio di algoritmi per la ricerca dei percorsi più brevi nei grafi è piuttosto celebre in letteratura, è ormai facile elaborare un'implementazione che permetta di risolvere questo problema, verrà effettuata quindi una rapida implementazione ed analisi. Differente è il discorso per agli algoritmi che lavorano in grafi con più pesi, per i quali è più difficile reperire implementazioni ed analisi. Inoltre, essendo un lavoro di ottimizzazione mi concentrerò sull'analisi di grafi con due pesi, seppur alcuni algoritmi siano applicabili anche a grafi con un più vasta moltitudine di valori.
		%
		
	\end{abstract}
	
\begin{titlepage}                       %crea un ambiente libero da vincoli 
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
%
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Dedico questo mio modesto lavoro a tutti coloro\\
Che mi sono stati vicini e mi hanno sostenuto\\
In questa piccola parte di un ancora lungo e faticoso cammino\\
In particolare alla mia famiglia \ldots                      %\ldots lascia tre puntini
\newpage                                %va in una pagina nuova
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage{\pagestyle{empty}\cleardoublepage}%non numera l'ultima pagina sinistra
\end{titlepage}


%\chapter*{Introduzione}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
%\rhead[\fancyplain{}{\bfseries
%INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
%\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
%INTRODUZIONE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
%\addcontentsline{toc}{chapter}{Introduzione}
%Questa \`e l'introduzione.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
%\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoffigures                          %crea l'elenco delle figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoftables                           %crea l'elenco delle tabelle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Introduzione}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
L'algoritmo di Dijkstra è largamente utilizzato in ambiti dove i problemi di routing riguardano grafi dove sono presenti valori statici non negativi. Questo celebre algoritmo però prende in considerazione una sola ``dimensione" dei costi;  se, ad esempio, ci fosse la necessità di calcolare il percorso in un grafo da un nodo \textit{sorgete} ad uno  \textit{destinazione} questo troverebbe il percorso addizionando volta per volta il peso relativo all'arco che connette due nodi che vengono "visitati" dall'algoritmo. Ma il problema si ha appunto nel momento in cui si hanno due o più criteri che relazionano due nodi; ad esempio la distanza e il pericolo. In questo caso si potrebbe scegliere tra diversi percorsi (seppur rappresentati all'interno di un grafo), ma non per forza il più corto è anche il più sicuro o vice versa. La ricerca di un percorso breve in termini di differenti criteri (molto più semplicemente in inglese `\textit{Muticriteria Shortest Paths Problem}') ha lo scopo di ottimizzare i costi dal nodo sorgente a quello di destinazione.\\
In generale non c'è una sola soluzione ottimale, bensì un insieme di possibili soluzioni, anche dette soluzioni ``non dominate" (verrà in seguito approfondito il significato di questa espressione). L'obiettivo di questo progetto è dunque quello di implementare l'algoritmo migliore che possa trovare questo insieme di soluzioni non solo minimizzando il primo o il secondo peso, ma la loro relazione.

\vspace{5mm}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{exampleGraph1}
	\caption{Grafo d'esempio.}
	\label{fig:graphExample}
\end{figure}

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		$p1$ & $1\to2\to4\to6$ & (11, 25) \\ \hline
		$p2$ & $1\to2\to5\to6$ & (13, 11)  \\ \hline
		$p3$ & $1\to3\to5\to6$ & (21, 6)  \\ \hline
		$p4$ & $1\to3\to4\to6$ & (13, 18)  \\ \hline
	\end{tabular}
	\caption{Soluzione del grafo di esempio}
	\label{tab:graphExample}
\end{table}

La fig.\ref{fig:graphExample} mostra un esempio di grafo a due criteri. Ogni nodo è numerato $\{1,2,\dots,6\}$ ed i pesi presenti sugli archi sono rappresentati come una coppia di valori $(a,b)$. Se considerassimo il primo peso la distanza e il secondo peso, ad esempio, il pericolo, avremo i percorsi $p1$ e $p3$ come il più corto ed il più sicuro rispettivamente, differentemente $p2$ è una soluzione definita ``non dominata", infatti comprende un percorso più lungo rispetto a $p1$, ma al contempo più sicuro, mentre percorre un cammino più pericoloss, ma più corto rispetto a ``p3". $p4$ infine segue un percorso che non risulta vantaggioso ne per il primo valore ne per il secondo, in quanto non porta nessun vantaggio rispetto a $p2$ (la definizione formale di ``soluzione dominata" sarà formulata nel cap.3).

\section{Formulazione Matematica}                 %crea la sezione
Sia definita $G(N,A)$ un grafo orientato composto da un insieme finito di nodi (o vertici) $N = \{0,1,\dots,n\}$ e $A \subseteq N\times N $ di archi direzionati. Ogni arco può essere rappresentato come una coppia ordinata $(i,j)$, dove $i\in N$, $j \in N$ ed entrambi due nodi differenti ($i\neq j$) in $G(N,A)$.

Sia dunque definito $c^k_{i,j}$ dove $(i,j)\in A$ e $1\leq k \leq 2$ (dato che si tratta di un grafo con due pesi ad ogni arco) che rappresentano i costi relativi ad ogni arco. Considerando quindi due nodi del grafo, chiamati $s$ e $t$, dove $s,t\in N$, i quali rappresentano rispettivamente il nodo da cui iniziano i percorsi che cerchiamo (\textit{source}) ed il nodo terminale (\textit{target}).
Un cammino $p_{s,t}$ può essere rappresentato come una sequenza di nodi e archi, avente la seguente forma: $p_{s,t} = \{s, (s, i_1), i_1, \dots, i_{l}, (i_l,t), t\}$.\\
\'E dunque possibile affermare che ogni $c^k_{i,j}$ rappresenta il costo di uno dei $k$ pesi di ogni arco $(i,j)$, quindi il costo totale dell'intero cammino è rappresentato nel modo seguente:\\

\begin{gather}P = (c^1(p_{s,t}), c^2(p_{s,t}))\end{gather}
\begin{center}
	\textit{Dove $P$ è una soluzione}
\end{center}
\begin{gather}c^1(p_{s,t})=\sum_{(i,j)\in p}c^1_{i,j}\end{gather}
\begin{gather}c^2(p_{s,t})=\sum_{(i,j)\in p}c^2_{i,j}\end{gather}
Il nostro scopo è quello di \textbf{minimizzare} la ($1.2$) o la ($1.3$) e dunque ottenere lo ``spettro" di soluzioni che  è presente tra le due. Ad esempio considerando il caso succitato dove il primo peso rappresenta la lunghezza ed il secondo il pericolo, minimizzando la ($1.2$) otterremmo il percorso più breve, altrimenti il più sicuro.

\chapter{Algoritmi `Mono-criteria'}
In questo capitolo sono trattati esclusivamente i gli algoritmi che riguardano la ricerca di cammini minimi con un solo criterio di peso su ogni arco. L'analisi si concentra sull'implementazione e l'ottimizzazione dell'algoritmo di Dijkstra, spiegando alcune scelte implementative, e su di un altro celebre algoritmo in questo campo, l'\textit{A-star}

\section{Algoritmo di Dijkstra}
L'algoritmo di Dijkstra è molto celebre in letteratura e e tra chiunque abbia una conoscenza anche basica di algoritmi; è infatti molto usato per la ricerca dei cammini minimi in grafi connessi con archi aventi pesi positivi. Di seguito sono presenti brevi analisi di alcune interessanti implementazioni.

\begin{figure}
\begin{BVerbatim}
function DijkstraAlgorithm(source, target):
	dist[source] := 0
	create priorityQueue Q
	q.put(source, dist[source])
	while Q is not empty do
	    n := Q.extract_min()
	    for each neighbor in v of n do
	        alt := dist[n] + lenght(n, v)
	        if alt < dist[v] do
	            dist[v] := alt
	            prev[v] := n
	            Q.put(v, alt)
	return dist, prev
\end{BVerbatim}
\caption{Pseudocodice dell'Algoritmo di Dijkstra (list of candidate)}
\label{fig:dijkstraLoC}
\end{figure}

\subsection{One to All}
Questa implementazione è utile in caso si volessero trovare tutti i percorsi brevi da un nodo sorgente $s\in N$ ad ogni altro nodo del grafo, dunque non si ferma finché ogni nodo del grafo (raggiungibile da $s$) non vien visitato. A livello implementativo il nodo sorgente è realizzato in modo da contenere un dizionario contenente ogni nodo raggiunto, utilizzando come chiave l'indice del nodo e come valore la distanza (ovvero la somma dei pesi degli archi) minima che ha da $s$.

Implementando una coda di priorità si raggiunge una complessità di $O((|N|+|A|)\log_2(|N|))$ dove $N$ è il numero dei vertici del grafo, mentre $A$ è il numero degli archi. Il caso peggiore, dove $A>>N$, raggiunge una complessità di $O(|A|\log_2(|N|))$.

\subsection{One to One}
A differenza della precedente, questa implementazione si concentra sul classico algoritmo di Dijkstra; non va quindi a visitare ogni singolo nodo del grafo bensì si fermerà quanto avrà raggiunto un nodo specifico $t \in N$. Non implementando una coda di priorità, andrà ad interrogare ogni nodo non visitato del grafo ad ogni ciclo, costruendo così il percorso nodo per nodo. Questo procedimento è indubbiamente esoso, infatti la sua complessità computazionale è $O(|N^2|)$.

\subsection{List of Candidate}
Questa ultima versione dell'algoritmo di Dijkstra (di cui è possibile leggere lo pseudocodice in fig.\ref{fig:dijkstraLoC}) utilizza una coda di priorità particolare: gli elementi di questa coda infatti vengono aggiornati ad ogni ciclo. Considerano i nodi vicini di ogni nodo che viene visitato ed utilizza la loro distanza come valore di priorità; ogni volta che un nodo viene visitato viene anche rimosso dalla coda. Questa implementazione interroga molti meno nodi rispetto alle precedenti versioni, ma nonostante questo ha lo stesso caso peggiore di complessità dell'algoritmo `\textit{One to All}': $O((|N|+|A|)\log_2(|N|))$

\section{``A Star''}
L'algoritmo \textit{A star} (conosciuto anche come A*) può essere considerata un'estensione dell'algoritmo di Dijkstra,poiché riesce ad ottenere una migliore performance ed accuratezza usando l'euristica \footnote{\url{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}}. Per determinare in che modo A* deve estendere i suoi percorsi, necessita di minimizzare la seguente equazione:

$$ f(n) = g(n) + h(n)$$   
Dove:
\begin{itemize}
	\item $n$ è il prossimo nodo del cammino
	\item $g(n)$ è il costo che ha accumulato il percorso dall'inizio (nodo $s$) fino al nodo $n$
	\item $h(n)$ è la funzione euristica
\end{itemize}
La funzione euristica, in questo caso, è la distanza più breve tra $n$ ed il nodo finale ($t$) dunque \textit{la linea retta} o meglio la \textbf{distanza euclidea} che lo separa dal `target'. In questo caso la complessità computazionale è relazionata ad $h$ ed al numero di nodi esplorati per la costruzione del cammino minimo.
Dunque il caso peggiore è $O(|N|) \equiv O(b^d)$ dove $b$ è il numero medio dei successori per nodo e $d$ i nodi esplorati per trovare la soluzione.
\subsubsection*{dettagli implementativi}
Ad ogni iterazione:
\begin{enumerate}
	\item Il nodo con il valore minore di $f(n)$ è estratto dalla coda (implementata come una coda di priorità)
	\item Aggiorna i valori dei nodi vicini e li aggiunge alla coda in base alla priorità
	\item L'algoritmo prosegue finché non viene raggiunto l'obbiettivo
\end{enumerate}
La \textbf{Distanza Euclidea} tra due punti è: $$\sqrt{(i_x - t_x)^2 + (i_y - t_y)^2}$$
Dove $i$ è un nodo del grafo e $t$ è il nodo che vogliamo raggiungere, $x$ e $y$ rappresentano le coordinate Cartesiane (nei grafi di esempio utilizzati, dato che rappresentano delle città, vengono convertiti da latitudine e longitudine dei vari punti).

Dato che il calcolo della radice quadrata è molto costoso in termini di tempo,è necessario trovare un modo per evitare di ripetere questa operazione in caso un singolo nodo venga visitato più volte (nell'implementazione utilizzata viene salvato nel nodo e quindi non viene più ricalcolato).

\begin{figure}
	\begin{BVerbatim}
function DijkstraAlgorithm(source, target):
    score[source] := 0
    create priorityQueue Q
    q.put(source, score[source])
    while Q is not empty do
        n := Q.extract_min()
        for each neighbor v of n do
            if v not visited do
                tmpScore := score[n] + lenght(v, n)
                if tmpScore < score[v] do
                    if euclidean[v] is None do
                        euclidean[v] := calcEuclidean(v, target)
                score[v] := tmpScore
                prev[v] := n
                Q.put(v, tmpScore)
    return score, prev
	\end{BVerbatim}
	\caption{Pseudocodice dell'Algoritmo A*}
	\label{fig:Astar}
\end{figure}
\section{Analisi dei Risultati}
Ora vediamo un elenco puntato:
\subsection{Performance a Confronto}
\subsection{Nodi Visitati}

\chapter{Algoritmi Bi-criteria}
In questo capitolo si andrà più nello specifico ad analizzare il problema ed a studiare alcune soluzioni; per poi valutarle in base ai risultati ottenuti. Tenendo in mente le espressioni matematiche formulate nel capitolo precedente possiamo soffermarci su alcune definizioni importanti:

\theoremstyle{definition}
\newtheorem{definition}{Definizione}
\begin{definition}{Concetto di Dominanza}\\
	Siano $X=(c^1(p_{s,t}),c^2(p_{s,t}))$, $Y=(c'^1(p_{s,t}),c'^2(p_{s,t}))$ due possibili cammini distinti da un nodo $s \in N $ ad un nodo $t \in N$. Si dice che $X$ \emph{domina} $Y$ se e solo se $c^1(p_{s,t}) < c'^1(p_{s,t}) \wedge c^2(p_{s,t}) < c'^2(p_{s,t})$.\\
	In questo caso X è detta \textbf{soluzione accettabile} (al contrario Y non verrebbe in alcun caso presa in considerazione).
\end{definition}

\theoremstyle{definition}
\begin{definition}{Inviluppo Convesso delle soluzioni}\\
	Sia $S$ un inseme di soluzioni accettabili, l'inviluppo convesso (conosciuto anche come \textit{Convex hull}) di $X$ è il più piccolo insieme convesso contenente X. Dato che consideriamo due dimensioni per il calcolo del percorso, ci troviamo in uno spazio euclideo a due dimensioni. L' inviluppo convesso può quindi essere definito dalla seguente equazione:
	\begin{equation}\label{eq:convex hull}
		\alpha*c^1_{(p_{s,t})} + (1-\alpha) c^2_{(p_{s,t})} = k
	\end{equation}
	\begin{center}
		Dove $k$ è una costante e $\alpha \in \{0, 1\}$.\\
	\end{center}
\end{definition}

\theoremstyle{definition}
\begin{definition}{Fronte di Pareto}\\
	Il fronte di Pareto è l'insieme delle soluzioni ottimali, ovvero l'insieme di tutti i cammini \textit{non-dominati}. Una soluzione può far parte del fronte di Pareto senza dominare altre soluzioni e senza essere compreso all'interno dell'inviluppo convesso delle soluzioni.
	
\end{definition}

\section{Dijkstra applicato ad un problema Bi-criteria}
Partendo dalla definizione classica di \textit{grafo} è possibile fare un'astrazione e scrivere $G = (N,V, C)$, dove $C$ è l'insieme dei costi. La suddetta definizione, quindi, +possibile estenderla ad un ``grafo bi-critera" come $G = (N,V, C^1, C^2)$, dove $C^1$ e $C^2$ sono gli insiemi dei soliti due pesi, ma in questo modo l'algoritmo di Dijkstra non è applicabile. Utilizzando la \ref{eq:convex hull} è possibile ridurre questa nuova definizione come  a $G = (N,V, \alpha*C^1_i + (1-\alpha)C^2_i)$ e, considerando che la \ref{eq:convex hull} ha come risultato un elemento costante, sarà possibile un approccio simile agli algoritmi affrontati nel precedente capitolo.\\
L'algoritmo di Dijkstra `\textit{list of candidate}'è il più vantaggioso, dato che non è possibile, in questo caso generico, individuare un funzione euristica che risolva in maniera ottimale l'equazione.
\\

\'E facilmente comprensibile che utilizzando la \ref{eq:convex hull}, in base al valore dato ad $\alpha$ otterremo un cammino che minimizza più un peso piuttosto che l'altro. Per esempio, ponendo il primo peso come \textit{tempo di latenza} ed il secondo come \textit{consumo energetico}, più il valore di $\alpha$ so avvicina a $0$ più troveremo un percorso con una grande latenza ma un basso consumo energetico, mentre se questo valore si avvicina a $1$ allora il percorso avrà meno latenza ma un consumo energetico inferiore.
\\
La complessità computazionale è la stessa dell'algoritmo di Dijkstra mostrato precedentemente. Di seguito è riportato il codice che descrive questo ragionamento.

\begin{figure}
	\begin{BVerbatim}
function DijkstraAlgorithm(source, target, alpha):
	score[source] := 0
	create priorityQueue Q
	Q.put(source, score[source])
	while Q is not empty do
	    n := Q.extract_min()
	    for each neighbor v of n do
	        alt := alpha*firstW(n, v) + (1 - alpha)*secondW(n, v)
	        alt := alt + score[u]
	        if alt < score[v] do
	            score[v] := alt
	            prev[v] :=n
	            Q.put(v, tmpScore)
	return score, prev
	\end{BVerbatim}
	\caption{Pseudocodice dell'Algoritmo di Dijkstra utilizzato con due criteri}
	\label{fig:Dijkstra Bicrit}
\end{figure}

Poiché questo algoritmo ha alla base la formula dell'inviluppo convesso, significa che i suoi risultati andranno a creare la curva che ne concettualizza il significato. Vediamo di seguito.

\subsection{Implementazione dell'algoritmo di Dijkstra con due criteri}
Per utilizzare l'algoritmo sopracitato ed ottenere un numero soddisfacente di risultati è necessario richiamarlo ogni volta con un diverso valore di $\alpha$.

\subsubsection{Iterazione Dijkstra bi-criteria}
Questa è un implementazione piuttosto basilare, si basa semplicemente sul richiamare l'algoritmo partendo con $\alpha$ uguale a $0$, per poi aumentarne il valore di un numero arbitrario chiamato \textbf{precisione}; se il risultato è differente da quello precedente allora il cammino viene salvato ed il valore di $\alpha$ dimezzato, altrimenti si prosegue, fino a che non si raggiunge $\alpha = 1$.
\\
Questa soluzione richiede un tempo di elaborazione in relazione alla precisione utilizzata, infatti più questa è piccola, più volte verrà richiamata la funzione, dunque si otterranno differenti risultati (\textit{soluzioni accettabili}); ma ciò significa anche che la funzione spesso darà dei risultati inutili, sprecando cicli preziosi.

\subsubsection{Dijkstra bi-criteria con ricerca binaria}
Questa è una versione un po' meno grezza della precedente, dato che utilizza un algoritmo di ricerca binaria. Viene eseguita la funzione almeno due volte, una con $\alpha = 0$, poi una con $\alpha = 0$; se generano risultati differenti allora il valore di $\alpha$ viene dimezzato, e così via finché non si trovano più soluzioni. Seppur più efficiente rispetto ad un'iterazione con alta precisione, in termini di tempo e di risultati trovati non risulta essere perfetto.
\\

Di seguito è presente una tabella che mostra i risultati tra due esecuzioni dell'iterazione dell'algoritmo bi-criteria di Dijkstra, con differenti precisioni, e l'implementazione con la ricerca binaria.\\

\begin{table}                    %ambiente tabella
\centering                         %(serve per avere la legenda)
\textit{{\tiny Questi risultati sono stati calcolati sulla mappa di Parigi (vd. risorse), considerando come partenza il nodo avente indice 2000 e come nodo terminale quello di 2689}}
\begin{tabular}{ |p{4cm}||m{3cm}|p{3cm}|  }
	\hline
	Valore di $\alpha$ & PESO 1 & PESO 2 \\
	\hline
	\multicolumn{3}{|c|}{Iterazione con \textbf{precisione} = 0.2} \\
	\hline
	
	 $\alpha$ = 0   & 9231    &12827\\
	 $\alpha$ = 0.2 &   7153  & 12884\\
	 $\alpha$ = 0.7 & 6091 &  14230\\
	 $\alpha$ = 0.55 & 6317 &  13754\\
	 $\alpha$ = 0.875 &   5944  & 14824\\
	 $\alpha$ = 1 & 5840 & 16763 \\
	\hline
	\multicolumn{3}{|c|}{AVGtime: 2.112018585205078} \\ 
	\hline\hline
		\multicolumn{3}{|c|}{Iterazione con \textbf{precisione} = 0.05} \\
	\hline
	 $\alpha$ = 0   & 9231    &12827\\
	 $\alpha$ = 0.05 &   7153  & 12884\\
	 $\alpha$ = 0.525 & 6317 &  13754\\
	 $\alpha$ = 0.7125000000001 & 6091 &  14230\\
	 $\alpha$ = 0.8062500000004 &   6030  & 14430\\
	 $\alpha$ = 0.8531250000005  & 5944 & 14824 \\
	 $\alpha$ = 0.9265625000006  & 5874 & 15649 \\
	 $\alpha$ = 1  & 5840 & 16763 \\	
	\hline
		\multicolumn{3}{|c|}{AVGtime: 7.837886095046997} \\  
	\hline\hline
		\multicolumn{3}{|c|}{Dijkstra con ricerca binaria} \\
	\hline
  $\alpha$ = 1 & 5840  &  16763\\
  $\alpha$ = 0 & 9231  &  12827\\
  $\alpha$ = 0.5 & 7153  &  12884\\
  $\alpha$ = 0.75 & 6091  &  14230\\
  $\alpha$ = 0.625 & 6317  &  13754\\
  $\alpha$ = 0.875 & 5944  &  14824\\
  $\alpha$ = 0.812 & 6030  &  14430\\
  $\alpha$ = 0.937 & 5874  &  15649\\
  $\alpha$ = 0.9680000000001 & 5855  &  16199\\
  $\alpha$ = 0.9660000000001 & 5863  &  15959\\
  $\alpha$ = 0.9740000000001 & 5847  &  16493\\
	\hline
	\multicolumn{3}{|c|}{AVGtime: 4.851694107055664} \\ 
	\hline
\end{tabular}
\caption{Output dei due algoritmi di Dijkstra bi-criteria a confronto}
\label{table:dijkstra bicrit}
\end{table}
Da questi risultati è infatti possibile notare come una bassa precisione permette di avere un determinato insieme di risultati in tempi ragionevolmente bassi, differentemente si può dire dell'iterazione con precisione alta. Con la ricerca binaria è possibile ottenere un range abbastanza ragionevole di risultati in tempi discreti.


\section{Algoritmo di Label-setting}
Come precedentemente scritto, l'algoritmo di Dijkstra applicato a due criteri non è in grado di trovare tutte le soluzioni possibili (con qualsiasi livello di precisione), bensì solo quelle che compongono l'inviluppo convesso. Dunque se noi volessimo trovare un più amplio insieme di soluzioni non dominate, dunque se volessimo trovare il \textit{Fronte di Pareto} dobbiamo affidarci ad un algrotimo di Label-setting. Di seguito è presente un'esempio  di quanto detto, dove vengono messi a confronto le soluzioni trovate da Dijkstra applicato a due criteri e l'algoritmo trattato in questo capitolo. Nell'esempio vengono utilizzati la distanza ed il pericolo come valori che contraddistinguono i due pesi in questione. 
\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{graphDijkstraBicrit.png}
		\caption{Soluzioni trovate da \textit{Dijkstra bi-criteria con ricerca binaria}}
		\label{fig:graphBiDi}
	\end{minipage}
	%\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{graphLabelsetting.png}
		\caption{Soluzioni trovate dall'algoritmo \textit{Label-setting}}
		\label{fig:graphLabSet}
	\end{minipage}
	\textit{{\tiny Questo esempio è stato calcolato utilizzando la mappa di Parigi, coprendo il tragitto che va dal nodo 2000 al nodo 2689.}}
\end{figure}

Nel grafo in figura \ref{fig:graphLabSet} sono presenti solo alcuni punti appartenenti alla \textit{convex hull} (quadrati rossi), mentre nel grafico affianco snono presenti tutte le soluzioni ottenute con l'algoritmo di label-setting (punti gialli). Infatti, come è anche possibile vedere, nel grafico a destra alcuni punti gialli trovano corrispondenza in tutti i punti trovati nel grafico a sinistra. Le soluzioni trovate quindi dall'algoritmo di label-setting sono tutte accettabili, dunque il suo insieme di soluzioni è più completo.

\subsection{Implementazione}
Questo algoritmo è basato, da come si può intuire dal nome, sul creare e salvare appunto dei `\textit{label}' dove sono contenute le informazioni sul percorso che si affronta per andare da un nodo ad un altro del grafo. I label sono strutturati in questo modo: $$(peso1, peso2, proprietario, predecessore, indiceDelPossessore, indiceDelPredecessore)$$
I primi due parametri rappresentano i costi del cammino dal nodo sorgente, il terzo ed il quarto sono rispettivamente il nodo possessore del label ed il suo predecessore (o vero il nodo antecedente, da dove ``arriva" il cammino), gli ultimi due valori invece, utilizzati per il `\textit{backtracking}' del percorso, indicano la posizione del label in corrispondenza del loro nodo possessore e del loro predecessore.
\\

\begin{verbatim}
function DijkstraAlgorithm(source, target):
    originLabel := (0, 0, source, Null, 0, Null)
    source.add(originLabel)
    create priorityQueue Q
    Q.put(orginLabel, priority())
    while Q is not empty do
        actualLabel := Q.extract_min()
        owner := actualLabel[2]
        for each neighbor v of owner do
            firstW = weightOne(owner, v) + actualLabl[0]
            secondW = weightTwo(owner, v) + actualLabel[1]
            vIndex = v.labelIndex()
            predIndex = owner.labelIndex()
            label = (firstW, secondW, v, owner, vIndex, predIndex)
            if label is not dominated by v.labels() do
                v.labelsAdd(label)
                if v is not target do
                    Q.put(label, priority())
\end{verbatim}
\\
Spiega i tre casi del label dominato, poi il fatto che non ha ritorno, l'implementazione per risparmiare qualche ciclo, il fatto che sia molto simele a dijkstra perché da lui è ispirato

\subsubsection{Primo Listato}
\begin{verbatim}
        In questo ambiente     posso scrivere      come voglio,
lasciare gli spazi che voglio e non % commentare quando voglio
e ci sarà scritto tutto.
Quando lo uso è meglio che disattivi il Wrap del WinEdt
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%per fare le conclusioni
\chapter*{Conclusioni}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Conclusioni
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Conclusioni} Queste sono le
conclusioni.\\
In queste conclusioni voglio fare un riferimento alla
bibliografia: questo \`e il mio riferimento \cite{K3,K4}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\renewcommand{\chaptermark}[1]{\markright{\thechapter \ #1}{}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\appendix                               %imposta le appendici
\chapter{Prima Appendice}               %crea l'appendice
In questa Appendice non si \`e utilizzato il comando:\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\verb"" è equivalente all'
                                        %   ambiente verbatim,
                                        %   ma si utilizza all'interno
                                        %   di un discorso.
\verb"\clearpage{\pagestyle{empty}\cleardoublepage}", ed infatti
l'ultima pagina 8 ha l'intestazione con il numero di pagina in
alto.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries \thechapter \:Prima Appendice}]
{\fancyplain{}{\bfseries\thepage}}
\chapter{Seconda Appendice}             %crea l'appendice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries \thechapter \:Seconda Appendice}]
{\fancyplain{}{\bfseries\thepage}}
\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} Primo oggetto bibliografia.
\bibitem{K2} Secondo oggetto bibliografia.
\bibitem{K3} Terzo oggetto bibliografia.
\bibitem{K4} Quarto oggetto bibliografia.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Ringraziamenti}
\thispagestyle{empty}
Qui possiamo ringraziare il mondo intero!!!!!!!!!!\\
Ovviamente solo se uno vuole, non \`e obbligatorio.
\end{document}



















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliografia bonus:
%P. E. Hart, N. J. Nilsson, B. Raphael: A Formal Basis for the Heuristic Determination of Minimum Cost Paths, IEEE Transactions on Systems Science and Cybernetics SSC4 (2), pp. 100?107, 1968.
% P. E. Hart, N. J. Nilsson, B. Raphael: Correction to "A Formal Basis for the Heuristic Determination of Minimum Cost Paths", SIGART  Newsletter, 37, pp. 28?29, 1972.
% N. J. Nilsson, Principles of Artificial Intelligence, Tioga Publishing Company, Palo Alto, California, 1980.
