\documentclass[a4paper,11pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{enumitem}
%\usepackage{algorithmic}
\usepackage[utf8]{inputenc}
\usepackage{fontenc}
\usepackage{amsthm}
\usepackage[english]{babel}
%stmaryrd,algorithm
\usepackage{amsmath,mathtools}
\usepackage{amssymb}
% Remove option to use English naming
\usepackage[english]{cleveref}
\graphicspath{ {img/} }

\usepackage{amsmath}

\newcommand{\RN}[1]{%
	\textup{\lowercase\expandafter{\romannumeral#1}}%
}

\title{Supervised Project ``Bicriteria Paths Problem''}
 
\author{Andrea Rossolini}
\date{\today}


\begin{document}
 
\maketitle

\begin{abstract}
In this paper I analyze a \textit{pathfinding} problem starting from a classical shortest path problem and then, after several optimization, going to resolve a graph that utilizes two static weights on his arches, considering the most full satisfying set of solutions.

As is known, Dijkstra's algorithm is most widely used to solve routing problems; in fact is very easy to create an implementation that attempts to find the best path in a classical weighted graph. So I will focus on the operations of optimization.
%
The most important part of the paper is the one that analyze the paths of a graph with two weights for each arches of it, one value represent the distance (also present in the monocriteria problem) and the other represent the danger of that arch. So the implementation will find not only the shortest and safest path, but also all the paths (not dominated) that take intermediate values. Two different algorithms will be shown for the analysis of the bicriteria problem.
\end{abstract}

\tableofcontents

\chapter{Introduction}
Dijkstra's algorithm, as already mentioned above, is widely used to find shortest path in routing problems that's use graphs with not-negative, static values. But this algorithm takes into consideration only one "dimension" of costs; for example, to calculate a path from the source node to the destination, distance is the result of adding up the length between two nodes segment by segment.
%
But the problem faced in our study considers two criteria for choosing the wanted path: the first cost defines the distance, while the second one represent the danger. So, the problem with Dijkstra is that we will found a path very short, but very dangerous, or vice versa. Concerning multicriteria shortest path problem is intended to determine a path that optimizes the costs from a source to the target, but, in general, there is no a single optimal solution, so the goal of this project is to determinate a set of feasible and not-dominated solution, founding different paths 
based on the two criteria, so is not sufficient minimizing distance or danger, but the relations between this two values.
\vspace{5mm}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{img/exampleGraph1}
	\caption{Graph example.}
	\label{fig:graphExample}
\end{figure}

\begin{table}[]
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		$p1$ & $1\to2\to4\to6$ & (11, 25) \\ \hline
		$p2$ & $1\to2\to5\to6$ & (13, 11)  \\ \hline
		$p3$ & $1\to3\to5\to6$ & (21, 6)  \\ \hline
		$p4$ & $1\to3\to4\to6$ & (13, 18)  \\ \hline
	\end{tabular}
	\caption{Graph's solution}
	\label{tab:graphExample}
\end{table}

In fig.\ref{fig:graphExample} is shown an example of a double criterion's routing. The nodes are labeled with numbers $\{1,2, ..., 6\}$ and the weights of the arches are represented as a pair of value (\textit{a, b}), where \textit{a} is distance and \textit{b} is danger.

In table \ref{tab:graphExample} are shown all the possible graph's iterations, $p1$ and $p3$ respectively the shortest and the safest paths, $p2$ is a not-dominated solution (it is longer than $p1$ but safer, more dangerous then $p3$, but, in this case, shorter) and $p4$ is a dominated path, so is useless to us.


 
\section{Mathematical formulation}

Let $G(N,A)$ denotes direct network which is composed of a finite set $N=\{0,1, \dots, n\}$ of nodes and a finite set $A \subseteq N\times N $, that represents the set of directed edges. Each arc can be denoted as an order pair $(i,j)$, where $i\in N$, $j \in N$ and both are two different nodes in $G(N,A)$.\\
Let define $c^k_{i,j}$ where $(i,j)\in A$ and $1\leq k \leq 2$ (because we are talking about a double criterion problem) represent the cost which we are referring to. We define two nodes in the graph: $s$ and $t$, where $s \in N$ and $t \in N$, these are respectively the \textit{source} and \textit{target} of which we want to find one or more paths.
%dei quali noi vogliamo trovare uno o più percorsi
We can qualify a path $p_{s,t}$ as a sequence  of  alternating nodes and arcs $p_{s,t} = \{s, (s, i_1), i_1, \dots, i_{l}, (i_l,t), t\}$.\\
So we said that each $c^k_{i,j}$ refers to one of the two costs of each arch $(i,j)$, therefore the total cost of the entire path can be represented in this way:\\

\begin{gather}(c^1(p_{s,t}), c^2(p_{s,t}))\end{gather}
\begin{gather}c^1(p_{s,t})=\sum_{(i,j)\in p}c^1_{i,j}\end{gather}
\begin{gather}c^2(p_{s,t})=\sum_{(i,j)\in p}c^2_{i,j}\end{gather}
Our purpose is to \textbf{minimize} the $(1.2)$ to find the shortest path or the $(1.3)$ to find the safest one.

\chapter{Mono-criteria algorithms}

In this chapter will be explained the algorithms which concern the single criteria routing.
The analysis focuses on the evolution and optimization of the following algorithm, explaining some implementation choices.

\section{Dijkstra's algorithms}

Dijkstra's algorithm is a very famous algorithm used to find the shortest paths between nodes in a graph connected by arches with positive weights.\\
Different implementation of this algorithm are present in this paper, as follows are all explained.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{img/dijkstraLoC.png}
	\caption{Pseudocode - Dijkstra (List of Candidates)}
	\label{fig:dijkstraLoC}
\end{figure}

\subsection{One to all}
This implementation is useful to find \textbf{all the shortest path} from a source node to each other graph's nodes. The starting node will save a dictionary where there is a key for each reached node and the respective value of distance.
It implement a \textit{priority queue} so the complexity of this implementation is $O((|N|+|A|)\log_2(|N|))$ where $N$ is the number of vertices and $A$ the number of edges. In the worst case, so where $A>>N$, the time complexity is $(|A|\log_2(|N|))$.

This implementation explores all the nodes reachable from the source; so it doesn't stop until the graph is totally explored.

\subsection{One to one}
This implementation focuses to find the shortest path between the node source and the target, using the classical implementation of Dijkstra's algorithm.\\
The difference from this to the previous implementation is that this doesn't use a priority queue, but the algorithm will interrogate each not-visited node every loop; this is very time consuming, in fact the complexity of this implementation is $O(|N^2|)$.
%TODO: controlla la grammatica qua
%la differenza tra questa e la precedente implementazione sta nel fatto che questa non implementa 

\subsection{List of candidate}
The last version of Dijkstra's algorithm is an implementation that uses a priority queue. The elements of this queue are insert by each new visited node, so the queue's elements are the neighbors of the visited node; in this way the algorithm needs to interrogate only some nodes and not all graphs.\\
The list of candidate algorithm has the same \textit{worst-case complexity} of the \textit{One to all} algorithm: $O((|N|+|A|)\log_2(|N|))$.

This implementation is faster than the previous: details of improvement are visualized and studied in the dedicated section.

\section{''A Star'' algorithm}
The A Star algorithm (or 'A*') is almost an extension of Dijkstra's algorithm, but it achieves better performance and accuracy by using (generically) heuristics. To determinate which of its paths to extend, A* does so based on the cost of the path and an estimate of the cost required to expand the path to the goal.

So A* select nodes that minimize:
$$ f(n) = g(n) + h(n)$$
\begin{itemize}
	\item $n$ is the next path's node
	\item $g(n)$ is path's cost from the beginning to $n$
	\item $h(n)$ is the heuristic function
\end{itemize}
Heuristic, in this case, is the shortest distance from $n$ to the goal, so a \textit{straight-line} or better the \textbf{euclidean distance} to the target.
According with \footnote{\url{https://en.wikipedia.org/wiki/A*_search_algorithm}} the time complexity is related to $h$ and the number of nodes explored is exponential in the depth of the shortest path solution.
So the worst case is $O(|N|) \equiv O(b^d)$ where $b$ is the average number of successors per node and $d$ the depth of the solution.
\subsubsection*{implementation's details}
At each iteration:
\begin{enumerate}
	\item The node with the lowest $f(x)$ is popped by the queue (implemented as a priority queue).
	\item Update the values of the neighbors and then add them to the queue.
	\item The algorithm repeat until the goal is visited.
\end{enumerate}
The Euclidean distance between two points is: $$\sqrt{(i_x - t_x)^2 + (i_y - t_y)^2}$$
where $i$ is a node of the graph and $t$ the target, $x$ and $y$ are latitude and longitude.


\section{Analysis of the results}
This paragraph shows the principal characteristics and results of each implementation.
\subsection{Time consuming} 
In the figure \ref{fig:monoCriteriaOutput} are shown some results, from 15 different iteration, classified in three "set" that groups different path's length.
\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{monoCriteriaOutput.png}
	\caption{Performance of the mono-criteria algorithms}
	\label{fig:monoCriteriaOutput}
\end{figure}
As possible to get from the table, we can recognize that the first column, '\textit{one$\to$all}', has a pretty much constant elaboration time (it comprehends the algorithm's work completion and the research in target node's attribute the distance from source). From the data of \textit{one$\to$one} algorithm is easily to recognize that the implementation without a priority queue is unsustainably slow, especially in the longest paths. From the latest two algorithm is possible to see that the \textit{A Star}'s implementation is more the 3 times faster than the \textit{List of candidate}, than from his part is near to be ten times more performing than the one to all implementation (which uses a priority queue).

\subsection{Node visited}

All the implementation are going to find the same paths between nodes; in particular all the implementation (except for the \textit{A Star}'s algorithm) explore the same nodes, instead, the 'not-Dijkstra's algorithm', explores less number of nodes, this means that it makes less loops during the elaboration and research of the shortest path.

In the following images is shown how, researching the shortest path, the algorithms visit nodes in a different way:\\
Dijkstra's algorithm (\textit{list of candidate}) makes a research more "circling" around the source (big green point), instead the 'A Star', for his nature, is more direct and it reaches the target exploring an "oval" between the starting nodes and the target. So is easy to see and understand how the last implementation is more efficient than the others.  
%TODO: add images of paths

\chapter{Bicriteria algorithms}

In this chapter are explained the algorithms implemented to studying the case of a graph with arches having two different weights.
Keeping in mind the mathematical explanation made in the introduction, we can enunciate some definitions:

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\begin{definition}{Feasible solution}\\
	Let $x, y$ be two distinct feasible path from a source $s$ to a target $t$. We say $x$ \emph{dominates} $y$ if and only of $c^k(x) \leq c^k(y)$ $\forall$ $k \in [1,2]$.
\end{definition}

\theoremstyle{definition}
\begin{definition}{Pareto front}\\
	For a given set of feasible solutions there is a subset of optimal solutions. It is simpler to understand graphically.
\end{definition}

\section{Dijkstra applied to bicriteria}
So, by the fact that we have to deal with two criterion, it's possible to introduce another variable: $\alpha$.\\
We also can now set the following variables: the distance $dist=c^1$ and the danger $dang=c^2$.\\
According with the function: 
\begin{equation}\label{eq:pareto front}
	\alpha*dist + (1-\alpha) dang = k
\end{equation}
\begin{center}
	where $k$ is constant and $\alpha \in [0, 1]$.
\end{center}
We can say that our graph $G=(N,V,dist,dang)$ is reducible to $G=(N,V,\alpha*dist + (1-\alpha) dang)$ and we can address the problem as the previous case, so using Dijkstra's algorithm (list of candidates) giving a value to $\alpha$.\\
It is easy to deduce that plus the value of $\alpha$ approaches $0$ means to find safest paths, instead, more $\alpha$ is near to $1$ means that we'll found shortest paths.

\vspace{5mm}

The algorithm's implementation is similar to Dijkstra's list of candidate, but with the difference that this version needs in input, as well as the source and the target, the value of $\alpha$; then, using \eqref{eq:pareto front}, the algorithm will choose the optimal path.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{img/bicriteriaDijkstra.png}
	\caption{Pseudocode - Dijkstra with two criterion}
	\label{fig:bicriteriaDijkstra}
\end{figure}
\
\subsection{Application of Bicrtieria Dijkstra}
The aforementioned algorithm is able to identify the most of the solution 
To use aforementioned algorithm, have been implemented two different functions.

\subsubsection{Bicriteria Dijkstra iteration}
This is a very raw version, its operation is based on recalling the pathfinding function, a lot of time, but every time with a different value for $\alpha$.

The time consuming is related to the chosen precision (the increasing value of $\alpha$), because it has to call the same function a lot of time and probably with the same result. So more precision means more results, but with a large waste of time.

\subsubsection{Bicriteria Dijkstra with binary research}
This version is an "evolution" of the last one, because it uses \textit{binary research}. It is based on calling the function at least two time: with $\alpha = 0$ and $\alpha=1$, then, if the result is different, with $\alpha=0.5$, again, if the result is different with $\alpha=\alpha/2$, and so on and so on; until there's no more solution.

This version generally is more efficient and precise than the other one. The output on figure \ref{fig:dijkstraBiCriteriaSimple} shown that with a precision of (e.g.) $0.2$ the \textit{Bicriteria iteration} is pretty faster than the binary research; while, with a smallest value for precision (little value means more precision), the \textit{Bicriteria iteration} becomes slowest and with less results than the \textit{binary search}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{img/biCriteriaOutput.png}
	\caption{Output of the two version of Dijkstra's bicriteria algorithm.}
	\label{fig:dijkstraBiCriteriaSimple}
\end{figure}

\section{Label-setting algorithm}
We said that the algorithm that use Dijkstra is not able to find all feasible solutions, but only those that make the \textit{Pareto front}; so this algorithm is useful if we want to know all the set of non-dominated solutions. Below a visualization on what we are talking about.

\begin{figure}[H]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{img/graphDijkstraBicrit.png}
		\caption{Graph generated by \textit{Bicriteria Dijkstra with binary search}}
		\label{fig:graphBiDi}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth, trim= 0 0 15mm 14mm, clip]{img/graphLabelsetting.png}
		\caption{Graph generated by \textit{Label-setting algorithm}}
		\label{fig:graphLabSet}
	\end{minipage}
\textit{{\tiny This example has been calculated using the map of Paris, starting from node 2000 to node 2689.}}
\end{figure}


In the graph \ref{fig:graphBiDi} are present only some point of the \textit{Pareto front} (red squares), while the second graph (\ref{fig:graphLabSet}) has much more points (yellow points) and as it is possible to see, the label-setting algorithm has found also the points found by Bicriteria Dijkstra too (Pareto front). The solutions found by label-setting algorithm are all feasible, so it is more complete, in fact, as it is possible to notice, there are no points with both values danger and distance greater than the others.


\subsection{Implementation}
Each node of the graph store a set of label with all the useful information "inside" his; the structure of label is as follow:
$$(distance, danger, owner, predecessor, ownerIndex, predIndex)$$
As it is deductible the first two parameter are the costs of the path from the source, the third and four elements indicate the node that own the label and from which node it comes, the fifth element is the label's position inside the label set of the owner node, the sixth indicate the position of parent's label inside his label set (used for backtracking).
As always the algorithm uses a priority queue where labels are stored and then chosen in function of the distance's value. The algorithm works in this way:

\begin{enumerate}[label=\roman*.]
	\item Create first label $(0,\ 0,\ s,\ null,\ 0,\ null)$ and put in the priority queue ($s$ represent the starting point).
	\item If the queue is empty perform step (\RN{6}) otherwise get the label with smallest distance's value from the queue and calculate the label for all his neighbors.
	\item Check if the calculated label is or less a non-dominated label. There's can be three different solution: the calculated label is dominated, so the algorithm will discards it; the calculated label dominate other labels, so we can delete those label; the calculated label doesn't dominate any other label, but it isn't dominated at all, so the algorithm will keep it.
	\item If the calculated label is feasible it is put in the queue, using the distance as a criteria for his priority.
	\item Return to step (\RN{2}).
	\item End.
\end{enumerate}
\subsubsection*{Example:}
We can study the graph in figure \ref{fig:graphExample} starting from node 1, so this node will have the label $(0,\ 0,\ 1,\ null,\ 0,\ null)$ in his set. Then creating labels for his neighbors (2 and 3): $(3,\ 4,\ 2,\ 1,\ 0,\ 0)$ and $(5,\ 3,\ 3,\ 1,\ 0,\ 0)$ and put both in the queue. Extracting label owned by node 2 and do the same thing as before and so on, until we reach the target node. At any new label we have to study if it is feasible or less before put it in the queue.

\subsection{Lower bound improvement}
\begin{center}
	\noindent\rule{8cm}{0.1em}
\end{center}
{\small The original thought was to make a preprocessing phase that would have retraced the path backwards and, in this way, calculates the distance (and danger) from the target to each visited node, to know in advice which would have been the lowest value for each of them. But i noticed that this thought doesn't work with graphs with edges between nodes oriented in more directions with different values for each direction. So I implemented a different solution, below there's the explanation.}
\begin{center}
	\noindent\rule{8cm}{0.1pt}
\end{center}
This algorithm use a technique to improve the speed, especially when it has to find paths between nodes far from each other. This technique consist in a \textit{preprocessing phase}, where, with Bicriteria Dijkstra algorithm, is possible to calculate the safest and the shortest path from the source to the target node and, for each visited node, store information about the distance of the visited node from the source, when we calculate the shortest path ($\alpha = 1$), and, in the same way, the danger counted from the beginning ($\alpha = 0$).

How it can be useful?
\\
We know that the research of the shortest and the safest path will generate the better value for distance and danger in any case and for each visited node. So, once calculated the value of distance of the shortest path and the value of danger for the safest, we also know, for a node elaborated in preprocessing phase, this information: the total value of the full path's distance (and danger), node's better value of distance (and danger), actual value of distance (and danger) calculated during the running of label-setting algorithm. 

Is possible to do this evaluation:
\begin{itemize}
	\item[-] $pd =$ best path's distance.
	\item[-] $nd =$ best node's distance.
	\item[-] $ad =$ actual node's distance, calculated at that exact moment by the algorithm.
	\item[-] $td =$ temporary value of distance.
	\item[-] $res =$ future value of distance for that specific node.
\end{itemize}
$$ td = pd - nd$$
$$res = td + ad$$
Doing the same thing with danger is possible to find the projection of the final label of that specific node and valuate if it is dominated or less.
\subsection{Complexity}
%TODO: nell'analisi mettici la complessità

\chapter{Analyse the results}

\chapter{Implementation choices}
\subsection{Nodes as objects}
\subsection{Pandas \& MatPlotLib}
\subsection{Testing}

\chapter{Personal considerations}
\subsection{Genetic algorithm}
\subsection{Difficulties encountered}



\bibliographystyle{abbrv}
\bibliography{template}

\end{document}
